{% extends 'base.html' %}

{% block title %}Home Page{% endblock %}

{% block content %}

<style>
    .midjourney-group {
        position: relative;
        width: 100%;
        max-width: 400px;
        cursor: pointer;
    }

    .midjourney-group-preview {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 2px;
        border-radius: 8px;
        overflow: hidden;
    }

    .midjourney-group-preview img {
        width: 100%;
        height: auto;
        object-fit: cover;
    }

    .midjourney-group-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .midjourney-group:hover .midjourney-group-overlay {
        opacity: 1;
    }

    .midjourney-detail-view {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.9);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .midjourney-detail-content {
        width: 90%;
        max-width: 1200px;
        background: #fff;
        border-radius: 12px;
        padding: 20px;
    }

    .midjourney-variations-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 16px;
        margin-top: 20px;
    }

    .variation-item {
        position: relative;
        cursor: pointer;
        transition: transform 0.2s;
    }

    .variation-item:hover {
        transform: scale(1.02);
    }

    .variation-number {
        position: absolute;
        bottom: 8px;
        left: 8px;
        background: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
    }
     .spinner-border {
            width: 2rem;
            height: 2rem;
            color: #333;
            margin-top: 20px;
            display: none;
        }

    .dropdown-item{
        cursor: pointer
    }
    #download-section {
            display: none;
        }
    .midjourney-group-container {
        @apply p-4;
    }

    .progress-container {
        @apply mt-4 mb-8;
    }

    .variation-number {
        @apply absolute bottom-2 left-2 bg-black bg-opacity-50 text-white px-2 py-1 rounded text-sm;
    }

    .image-actions {
        @apply absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity;
    }
    .generation-status {
        padding: 2rem;
        text-align: center;
    }

    .initial-grid {
        position: relative;
        overflow: hidden;
        border-radius: 0.5rem;
        margin-bottom: 2rem;
    }

    .initial-grid img {
        width: 100%;
        height: auto;
    }

    #upscale-progress {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 1rem;
        margin-top: 2rem;
    }

    .upscale-slot {
        position: relative;
        aspect-ratio: 1/1;
        background: #f3f4f6;
        border-radius: 0.5rem;
        overflow: hidden;
    }

    .progress-container {
        width: 100%;
        height: 4px;
        background: #e5e7eb;
        border-radius: 2px;
        overflow: hidden;
    }

    .progress-bar {
        height: 100%;
        background: #3b82f6;
        transition: width 0.3s ease;
    }
</style>
<div class="neltar_fn_page">

    <!-- Image Generation Page -->
    <div class="neltar_fn_image_generation_page">

        <div class="generation__page">

            <!-- Generation Header -->
            <div class="generation_header">
                <div class="header_top">
                    <h1 class="title">Image Generation</h1>
                    <div class="setup">
                        <p class="info">This wil use <span class="count">4</span> tokens</p>
                        <a href="#" class="sidebar__trigger">
                            <img src="{{ url_for('static', filename='assets/svg/option.svg') }}" alt="" class="fn__svg">
                        </a>
                    </div>
                </div>
                <div class="header_bottom">
                    <form id="generate-image-form">

                    <div class="include_area">
                        <textarea  id="prompt" placeholder="Entrez une description" required rows="1"></textarea>

                    </div>

                    <div class="generate_section">

                        <button type="submit" id="generate_it" href="#" class="neltar_fn_button btn btn-link">
                            <span id="generate-text">Générer l'image</span>
                            <div class="spinner-border" id="spinner" role="status"></div>
                        </button>
                    </div>
                </form>

                </div>


            </div>

            <div class="generation_history"  id="download-section">

                <!-- Ajoutez ces éléments dans  HTML -->

                <div id="historyLoader" class="text-center d-none">
                    <div class="spinner-border" role="status">
                        <span class="sr-only">Chargement...</span>
                    </div>
                </div>
                <div id="historyContent" class="fn__generation_list">
                    <!-- L'historique sera chargé ici -->
                </div>

                <div class="fn__generation_item">

                    <div class="item_list">
                        <ul class="fn__generation_list" style="justify-content: center;">
                            <li class="fn__gl_item" style="width: 400px;">
                                <div class="fn__gl__item">

                                    <div class="abs_item">

                                        <div id="generated-image">
                                            <!-- <img src="{{ url_for('static', filename='assets/img/gallery/1.jpg') }}" alt=""> -->

                                        </div>
                                        <div class="all_options">
                                            <div class="fn__icon_options medium_size">

                                                <div class="dropdown">
                                                    <button class="fn__icon_button dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                                        <img src="{{ url_for('static', filename='assets/svg/download.svg') }}" alt="" class="fn__svg">
                                                    </button>
                                                    <ul class="dropdown-menu dropdown-menu-dark">

                                                      <li class="dropdown-item" data-format="png">PNG</li>
                                                      <li class="dropdown-item" data-format="jpg">JPG</li>
                                                      <li class="dropdown-item" data-format="jpeg">JPEG</li>
                                                      <li class="dropdown-item" data-format="gif">GIF</li>

                                                    </ul>
                                                  </div>
                                            </div>

                                        </div>
                                    </div>
                                </div>
                            </li>

                        </ul>
                    </div>

                </div>

            </div>

            <div class="generation_history">

                <div class="fn__generation_item">
                    <div class="item_header">
                        <div class="title_holder">
                            <h2 class="prompt_title">Images History</h2>
                        </div>
                        <div class="item_options">
                            <div class="fn__icon_options medium_size align_right">
                                <a href="javascript:;" class="fn__icon_button" onclick="createNewInstance()">
                                    <img src="{{ url_for('static', filename='assets/svg/plus.svg') }}" alt="" class="fn__svg">
                                </a>

                            </div>

                        </div>
                    </div>
                    <div class="item_list">
                        <ul class="fn__generation_list sidebar" id="sidebar">

                            <!-- <li class="fn__gl_item">
                                <div class="fn__gl__item">
                                    <div class="abs_item">
                                            <img src="img/gallery/1.jpg" alt="">
                                    </div>
                                </div>
                            </li> -->


                        </ul>
                    </div>
                </div>

            </div>

        </div>

        <div class="generation__sidebar">
            <div class="sidebar_model">
                <div class="fn__select_model">
                    <a class="model_open">
                        <img class="user_img" src="{{ url_for('static', filename='assets/img/user/user.jpg') }}" alt="">
                        <div class="author">
                            <h4 class="subtitle">Model</h4>
                            <h3 class="title">GPT 4o</h3>
                        </div>
                        <span class="fn__icon_button">
                            <img src="{{ url_for('static', filename='assets/svg/arrow.svg') }}" alt="" class="fn__svg">
                        </span>
                    </a>
                    <div class="all_models">
                        <ul>
                            <li><a class="selected" href="#">GPT 4o</a></li>
                            <li><a href="#">Midjourney</a></li>

                        </ul>
                    </div>
                </div>
            </div>
            <div class="sidebar_details">
                <div class="number_of_images">
                    <h4 class="title">Number of Images</h4>
                    <div class="fn__quantity">
                        <a href="#" class="decrease"></a>
                        <input type="number" value="1" max="20" min="1">
                        <a href="#" class="increase"></a>
                    </div>
                </div>
                <div class="img_sizes">
                    <h4 class="title">Image Dimensions</h4>
                    <div class="img_size_select">
                        <select>
                            <option value="512_512" selected="">512 x 512px</option>
                            <option value="768_768">768 x 768px</option>
                            <option value="512_1024">512 x 1024px</option>
                            <option value="768_1024">768 x 1024px</option>
                            <option value="1024_1024">1024 x 1024px</option>
                        </select>
                    </div>
                </div>
                <div class="guidance_scale">
                    <h4 class="title">Image Dimensions<span class="fn__tooltip" title="Select the resoultion of the images."><img src="{{ url_for('static', filename='assets/svg/question.svg') }}" alt="" class="fn__svg"></span></h4>
                    <div class="fn__range">
                        <div class="range_in">
                            <input type="range" min="1" max="40" value="7">
                            <div class="slider"></div>
                        </div>
                        <div class="value">7</div>
                    </div>
                </div>
                <div class="prompt_magic_switcher">
                    <h4 class="title"><label for="prompt_switcher">Prompt Magic</label><span class="fn__tooltip" title="TechWave Prompt v3.0. Our custom render pipeline which has much faster compliance and can improve the result with any model selected. Applies a 2x multiplier to accepted costs due to higher GPU overhead."><img src="{{ url_for('static', filename='assets/svg/question.svg') }}" alt="" class="fn__svg"></span></h4>
                    <label class="fn__toggle">
                        <span class="t_in">
                            <input type="checkbox" checked="" id="prompt_switcher">
                            <span class="t_slider"></span>
                            <span class="t_content"></span>
                        </span>
                    </label>
                </div>
                <div class="contrast_switcher">
                    <h4 class="title"><label for="contrast_switcher">High Contrast</label><span class="fn__tooltip" title="If your photo consists of extremely bright and dark areas, then it's considered high contrast. When it has a wide range of tones that go from pure white to pure black, it's medium contrast. No pure whites or blacks and a range of middle tones means it's low contrast."><img src="{{ url_for('static', filename='assets/svg/question.svg') }}" alt="" class="fn__svg"></span></h4>
                    <label class="fn__toggle">
                        <span class="t_in">
                            <input type="checkbox" id="contrast_switcher">
                            <span class="t_slider"></span>
                            <span class="t_content"></span>
                        </span>
                    </label>
                </div>
            </div>
        </div>


    </div>
    <!-- !Image Generation Page -->

</div>

<script>
const LOGIN_URL = "{{ LOGIN_URL }}";

    document.querySelectorAll('.neltar_fn_wrapper').forEach(element => {
    element.classList.add('fn__has_sidebar');
});

    let currentModel = 'dall-e';
    let generatedImageUrl = '';
    const instances = [];

    //ajout supplémentaire !
    let currentPage = 1;
    let isLoading = false;
    let hasMore = true;

    // Écouteur pour le changement de modèle
    document.querySelectorAll('.all_models a').forEach(modelLink => {
        modelLink.addEventListener('click', function(e) {
            e.preventDefault();
            const modelName = this.textContent.toLowerCase();
            currentModel = modelName.includes('gpt') ? 'dall-e' : 'midjourney';
            console.error('model en question:', modelName)

            // Mise à jour visuelle
            document.querySelectorAll('.all_models a').forEach(link => {
                link.classList.remove('selected');
            });
            this.classList.add('selected');

            // Mise à jour du titre affiché
            document.querySelector('.model_open .title').textContent = this.textContent;
        });
    });

    document.getElementById('generate-image-form').addEventListener('submit', async function(event) {
        event.preventDefault();
        const promptInput = document.getElementById('prompt');
        const promptText = promptInput.value;
        const spinner = document.getElementById('spinner');
        const generateText = document.getElementById('generate-text');
        const downloadSection = document.querySelector('.fn__generation_item .item_list .fn__generation_list');
        const imageDiv = document.getElementById('generated-image');

        console.error('Current Model:', currentModel);
        console.error('Prompt:', promptInput.value);

        // Get the token from URL
        const urlParams = new URLSearchParams(window.location.search);
        const token = urlParams.get('token');

        promptInput.disabled = true;
        spinner.style.display = 'inline-block';
        generateText.style.display = 'none';
        downloadSection.style.display = 'none';

        try {
            updateLoadingState('loading');
            const response = await fetch(`/generate_image?token=${encodeURIComponent(token)}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-Requested-With': 'XMLHttpRequest'  // This identifies it as an AJAX request
                },
                body: `prompt=${encodeURIComponent(promptInput.value)}&model=${encodeURIComponent(currentModel)}`
            });

            const result = await response.json();
            // Handle token expiration and other auth errors
            if(response.status === 401 || response.status === 403){
                showErrorOverlay(
                    response.status === 401 ? 'Session Expirée' : 'Erreur d\'authentification',
                    result.message || 'Veuillez vous reconnecter.'
                );
                // Redirect after 3 seconds
                 setTimeout(() => {
                     window.location.href = result.redirect_url || LOGIN_URL;
                 }, 3000);
                 return;
            }
            if (result.success) {
                if (currentModel === 'midjourney' && result.status === 'processing') {
                    console.error('Starting Midjourney processing with task_id:', result.task_id);
                    // Cas Midjourney : attente du résultat
                    // Afficher un état initial de chargement
                    updateLoadingState('processing');
                    displayInitialLoadingState();
                    handleMidjourneyProcessing(result.task_id, token, promptText);
                } else {
                    // Cas DALL-E ou réponse immédiate
                    console.error('Displaying generated image:', result.image_url);
                    displayGeneratedImage(result.image_url);
                }
            } else {
                showErrorOverlay('Erreur', result.error || 'Une erreur est survenue');
            }
        } catch (error) {
            console.error('Error:', error);
            showErrorOverlay('Erreur', 'Impossible de contacter le serveur. Veuillez réessayer plus tard.');
        } finally {
            // Réactive l'interface
            spinner.style.display = 'none';
            generateText.style.display = 'inline';
            promptInput.disabled = false;
        }
    });

    // Fonction de gestion du traitement Midjourney
async function handleMidjourneyProcessing(taskId, token) {
    console.error('=== Starting Midjourney Polling ===');
    console.error('Task ID:', taskId);
    const generateText = document.getElementById('generate-text');
    generateText.textContent = 'Génération en cours...';

    const initialDelay = calculatePollingDelay(prompt);
    console.error(`Waiting ${initialDelay/1000} seconds before starting to poll based on prompt complexity`);

    await new Promise(resolve => setTimeout(resolve, initialDelay));

    let lastImagesCount = 0;
    const maxAttempts = 30;
    let attempts = 0;

    while (attempts < maxAttempts) {
        console.error(`Polling attempt ${attempts + 1}/${maxAttempts}`);
        try {
            console.error('Sending request with model:', currentModel);
            // Ajouter un timeout à la requête fetch
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 secondes

            const statusResponse = await fetch(`/check_midjourney_status/${taskId}?token=${encodeURIComponent(token)}`, {
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                },
                signal: controller.signal
            });

            clearTimeout(timeoutId)
            console.error('Status response:', statusResponse.status);

            // Ajoutez ces logs pour déboguer
            console.error(`Requested URL: /check_midjourney_status/${taskId}?token=[redacted]`);
            console.error(`taskId value: ${taskId}`);
            console.error(`taskId type: ${typeof taskId}`);

            if (!statusResponse.ok) {
                console.error(`Response not OK: ${statusResponse.status}`);
                // Tenter de lire le corps de la réponse pour plus d'informations
                try {
                    const errorText = await statusResponse.text();
                    console.error(`Error response body: ${errorText}`);
                } catch (readError) {
                    console.error(`Could not read error response: ${readError}`);
                }
                throw new Error('Erreur lors de la vérification du statut');
            }

            const statusResult = await statusResponse.json();
            console.error('Status data:', statusResult);

            // Mise à jour de la progression si disponible
            if (statusResult.success && statusResult.data) {
                const data = statusResult.data;

                // Si nous avons la grille initiale, l'afficher
                if (data.initial_grid && !document.querySelector('.initial-grid')) {
                    displayInitialGrid(data.initial_grid);
                }

                // Mettre à jour la progression des upscales
                if (data.images && Array.isArray(data.images) && data.images.length > lastImagesCount) {
                    // Check if we have new images to show progress
                    if (data.images.length > lastImagesCount) {
                        lastImagesCount = data.images.length;
                        updateUpscaleProgress(data.images);
                    }
                }

                // Si le groupe est complet
                if ((data.status === 'completed' || data.group_status ==='completed') && (data.images && data.images.length >=4)) {
                    console.error('Group complete, displaying results');
                    displayMidjourneyGroup(data);
                    console.error('call displayMidjourneyGroup');
                    updateLoadingState('complete');
                    return;
                } else if (data.images && data.images.length >=4) {
                    // If we have all 4 images but status isn't marked complete, show them anyway
                    console.error('All 4 images received, displaying anyway');
                    displayMidjourneyGroup(data);
                    updateLoadingState('complete');
                    return;
                }

                // Mettre à jour la barre de progression
                const progress = Math.min(90, (attempts / maxAttempts) * 100);(attempts / maxAttempts) * 100;
                updateProgressIndicator(progress);
            }

            // Gestion des erreurs spécifiques
            if (statusResult.status === 'failed' || statusResult.data?.status === 'failed') {
                showErrorOverlay('Erreur', 'La génération a échoué');
                updateLoadingState('default');
                return;
            }

            const delay = attempts < 5 ? 5000 : 10000;
            await new Promise(resolve => setTimeout(resolve, delay));
            attempts++;

        } catch (error) {
            console.error('Error in polling:', error);
            if (attempts === maxAttempts - 1) {
                showErrorOverlay('Erreur', 'Erreur lors de la vérification du statut');
                updateLoadingState('default');
                return;
            }
            await new Promise(resolve => setTimeout(resolve, 2000));
            attempts++;
        }
    }

    showErrorOverlay('Erreur', 'Le délai de génération a été dépassé');
    updateLoadingState('default');
}

// Fonction d'affichage de l'image générée
function displayGeneratedImage(imageUrl, isGroup = false) {
    if (isGroup) {
        // Pour les groupes Midjourney, attendre que toutes les images soient générées
        return;
    }
    console.error('Starting displayGeneratedImage with imageUrl:', imageUrl);

    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');
    console.error('Token retrieved:', token ? 'Token found' : 'No token');

    const fullImageUrl = `${imageUrl}?token=${encodeURIComponent(token)}`;
    console.error('Full image URL constructed:', fullImageUrl);

    generatedImageUrl = fullImageUrl;
    const imageDiv = document.getElementById('generated-image');
    console.error('Image div found:', imageDiv ? 'Yes' : 'No');

    // Utiliser le bon sélecteur pour cibler la liste qui contient l'image
    const downloadSection = document.getElementById('download-section');
    const imageContainer = document.querySelector('.fn__generation_item .item_list .fn__generation_list');

    console.error('Containers found:', {
        imageDiv: !!imageDiv,
        imageContainer: !!imageContainer,
        downloadSection: !!downloadSection
    });


    if (!imageDiv || !downloadSection || !imageContainer) {
        console.error('Image container missing');
        return;
    }
    const newImage = new Image();
    newImage.onload = function () {
        console.error('Test image loaded successfully');

        imageDiv.innerHTML = `
                <div class="abs_item" >
                    <img src="${fullImageUrl}" class="img-fluid mt-3" alt="Generated Image">
                    <div class="all_options">
                        <div class="fn__icon_options medium_size">
                            <div class="dropdown">
                                <button class="fn__icon_button dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                    <img src="/static/assets/svg/download.svg" alt="" class="fn__svg">
                                </button>
                                <ul class="dropdown-menu dropdown-menu-dark">
                                    <li class="dropdown-item" data-format="png" data-url="${fullImageUrl}">PNG</li>
                                    <li class="dropdown-item" data-format="jpg" data-url="${fullImageUrl}">JPG</li>
                                    <li class="dropdown-item" data-format="jpeg" data-url="${fullImageUrl}">JPEG</li>
                                    <li class="dropdown-item" data-format="gif" data-url="${fullImageUrl}">GIF</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>`;

        console.error('Image element present:', !!imageDiv.querySelector('img'));
        console.error('Image src set:', imageDiv.querySelector('img')?.src);

        downloadSection.style.display = 'block';
        imageContainer.style.display = 'block';

        console.error('Download section display style:', downloadSection.style.display);
        console.error('Image container display style:', imageContainer.style.display);

        // 4. Vérifier que l'image est bien visible
        const insertedImg = imageDiv.querySelector('img');
        if (insertedImg) {
            console.error('Image inserted successfully');
            insertedImg.onload = () => console.error('Inserted image loaded')
            insertedImg.onerror = () => console.error('Inserted image failed to load');
        } else {
            console.error('Failed to insert image element');
        }

        document.getElementById('generate-text').textContent = 'Générer une nouvelle image';

        loadHistory(1, false);
    };
    newImage.onerror = function() {
        console.error('Failed to load test image');
        showErrorOverlay('Error', 'impossible to load the image');
    };
    newImage.src = fullImageUrl;
}

function calculatePollingDelay(prompt) {
    if (!prompt || typeof prompt !== 'string') {
        console.error('Invalid prompt passed to calculatePollingDelay:', prompt);
        return 5000; // Return default delay if prompt is invalid
    }
    let baseDelay = 7000;
    const maxAdditionalDelay = 15000;
    let complexityScore = 0;

    const wordCount = prompt.split(/\s+/).length;
    if (wordCount > 50) complexityScore += 3;
    else if (wordCount > 30) complexityScore += 2;
    else if (wordCount > 15) complexityScore += 1;

    const complexityIndicators = [
        // Detailed styles and effects
        'realistic', 'photorealistic', 'hyper-realistic', 'detailed', 'intricate',
        'high resolution', 'high detail', '8k', '4k', 'ray tracing', 'volumetric lighting',

        // Complex scene descriptors
        'landscape', 'cityscape', 'panorama', 'scene', 'environment',

        // Multiple subjects
        'group', 'crowd', 'multiple', 'many',

        // Difficult rendering elements
        'reflection', 'glass', 'water', 'mirror', 'transparent', 'translucent',
        'chromatic aberration', 'bokeh', 'depth of field',

        // Specific artistic styles that take longer
        'oil painting', 'watercolor', 'concept art', 'matte painting',

        // Specific lighting conditions
        'sunset', 'sunrise', 'night scene', 'dramatic lighting', 'cinematic',

        // Atmosphere effects
        'fog', 'mist', 'rain', 'snow', 'particles',

        //complex rendering process
        'low angle', 'fisheye', 'first person view', 'a first-person view', 'POV'
    ]

    let indicatorCount = 0;
    complexityIndicators.forEach(indicator =>{
        if (prompt.toLowerCase().includes(indicator.toLowerCase())) {
            indicator++;
        }
    });

    // Add to complexity score based on number of indicators
    if (indicatorCount > 10) complexityScore += 5;
    else if (indicatorCount > 7) complexityScore += 4;
    else if (indicatorCount > 5) complexityScore += 3;
    else if (indicatorCount > 3) complexityScore += 2;
    else if (indicatorCount > 1) complexityScore += 1;

    complexityScore = Math.min(complexityScore, 7); //Max score of 7

    const additionalDelay = Math.min(complexityScore * 2000, maxAdditionalDelay);
    const totalDelay = baseDelay + additionalDelay

    console.log(`Prompt complexity score: ${complexityScore}, Total delay: ${totalDelay}ms`);
    return totalDelay
}

function updateLoadingState(state) {
    const generateText = document.getElementById('generate-text');
    const spinner = document.getElementById('spinner');

    switch(state) {
        case 'loading':
            spinner.style.display = 'inline-block';
            generateText.style.display = 'none';
            break;
        case 'processing':
            spinner.style.display = 'inline-block';
            generateText.textContent = 'Génération en cours...';
            generateText.style.display = 'inline';
            break;
        case 'complete':
            spinner.style.display = 'none';
            generateText.textContent = 'Générer une nouvelle image';
            generateText.style.display = 'inline';
            break;
        default:
            spinner.style.display = 'none';
            generateText.style.display = 'inline';
    }
}
// Nouvelle fonction pour afficher l'état initial
function displayInitialLoadingState() {
    const imageDiv = document.getElementById('generated-image');
    imageDiv.innerHTML = `
        <div class="generation-status">
            <div class="status-message">Génération en cours...</div>
            <div class="progress-container mt-4">
                <div class="progress-bar" style="width: 0%"></div>
            </div>
        </div>
    `;
}

function updateUpscaleProgress(images) {
    if (!Array.isArray(images)) {
        console.error('Expected images array for updateUpscaleProgress, got', images);
        return;
    }
    const progressSection = document.getElementById('upscale-progress') || createUpscaleProgressSection();
    if (!progressSection) {
        console.error('Failed to create or find upscale progress section');
        return;
    }

    images.forEach((image, index) => {
        // Get the variation/upscale number
        const variationNumber = getVariationNumber(image, index)
        const slot = document.querySelector(`#upscale-slot-${variationNumber}`);

        if (slot && image && image.url) {
            // Get the token to append to the URL if needed
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            const fullImageUrl = normalizeImageUrl(image.url, token);

            slot.innerHTML = `
                <img src="${fullImageUrl}" alt="Variation ${variationNumber + 1}"class="w-full h-full object-cover rounded"onerror="this.onerror=null; this.src='/static/assets/img/placeholder.png'; console.error('Failed to load image');">
                <div class="absolute bottom-0 left-0 bg-green-500 text-white px-2 py-1 text-sm rounded-tr">
                    Complété
                </div>
            `;
        }
    });
}

// Nouvelle fonction pour l'affichage de la grille initiale
function displayInitialGrid(imageUrl) {
    const imageDiv = document.getElementById('generated-image');
    const container = document.createElement('div');
    container.className = 'initial-grid mb-4';
    container.innerHTML = `
        <h4 class="text-center mb-2">Génération initiale</h4>
        <div class="relative">
            <img src="${imageUrl}" alt="Initial grid" class="w-full rounded">
            <div class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 text-white">
                <span>Génération des variations en cours...</span>
            </div>
        </div>
    `;
    imageDiv.innerHTML = '';
    imageDiv.appendChild(container);
}
// Function to create the upscale progress section if it doesn't exist
function createUpscaleProgressSection() {
    const imageDiv = document.getElementById('generated-image');
    if (!imageDiv) {
        console.error('Cannot find generated-image element');
        return null;
    }
    // Remove existing section if present to avoid duplicates
    const existingSection = document.getElementById('upscale-progress');
    if (existingSection) {
        existingSection.remove();
    }

    const progressSection = document.createElement('div');
    progressSection.id = 'upscale-progress';
    progressSection.className = 'grid grid-cols-2 gap-4 mt-4';

    // Create 4 slots for the 4 upscales
    for (let i = 0; i < 4; i++) {
        const slot = document.createElement('div');
        slot.id = `upscale-slot-${i}`;
        slot.className = 'upscale-slot flex items-center justify-center bg-gray-100';
        slot.innerHTML = `
            <div class="text-gray-400">
                <div class="spinner-border spinner-border-sm" role="status"></div>
                <div class="mt-2">En attente...</div>
            </div>
        `;
        progressSection.appendChild(slot);
    }

    imageDiv.appendChild(progressSection);
    return progressSection;
}

// 1. First, let's create a utility function for consistent URL handling
function normalizeImageUrl(imageUrl, token) {
    if (!imageUrl) return '';

    // If already a full URL
    if (imageUrl.startsWith('http')) {
        // Add token if needed
        if (token && !imageUrl.includes('token=')) {
            return `${imageUrl}${imageUrl.includes('?') ? '&' : '?'}token=${encodeURIComponent(token)}`;
        }
        return imageUrl;
    }

    // If it's a relative URL starting with /
    if (imageUrl.startsWith('/')) {
        const baseUrl = `${window.location.origin}${imageUrl}`;
        return token ? `${baseUrl}${baseUrl.includes('?') ? '&' : '?'}token=${encodeURIComponent(token)}` : baseUrl;
    }

    // Default case
    return token ? `${imageUrl}?token=${encodeURIComponent(token)}` : imageUrl;
}
// 2. Helper function for consistent variation number handling
function getVariationNumber(image, fallbackIndex) {
    if (typeof image.variation_number === 'number') return image.variation_number;
    if (typeof image.choice === 'number') return image.choice;
    return fallbackIndex || 0;
}

function displayMidjourneyGroup(groupData) {
    if (!groupData) {
        console.error('No group data provided');
        return;
    }

    const container = document.createElement('div');
    container.className = 'midjourney-group-container';
    console.error(container);

    // Afficher le prompt
    const promptDiv = document.createElement('div');
    promptDiv.className = 'prompt-container mb-4';
    console.error(promptDiv.localName)
    const safePompt = (groupData.prompt || "No prompt available")
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')

    promptDiv.innerHTML = `
        <h3 class="text-lg font-medium">${safePompt}</h3>
        <p class="text-sm text-gray-500">${new Date(groupData.timestamp || Date.now()).toLocaleString()}</p>
    `;
    container.appendChild(promptDiv);

    // Get token for URLs
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');


    // Grille d'images
    const grid = document.createElement('div');
    grid.className = 'grid grid-cols-2 gap-4';

    // Ensure images is an array and has items
    const images = Array.isArray(groupData) ? groupData.images : [];

    if (images.length > 0) {
        images.forEach((image, index) => {
            // Make sure we have a valid URL
            if (!image || !image.url) {
                console.error('Missing URL for image:', image);
                return;
            }

            // Normalize image.choice to a number (0-3)
            const choiceNum = getVariationNumber(image, index);
            // Ensure URL has token
            const imageUrl = normalizeImageUrl(image.url, token);

            const imageContainer = document.createElement('div');
            imageContainer.className = 'relative group';
            imageContainer.innerHTML = `
                <img src="${imageUrl}"
                     alt="Variation ${choiceNum + 1}"
                     class="w-full rounded shadow transition-transform duration-200 group-hover:scale-105 cursor-pointer"
                     onerror="this.onerror=null; this.src='/static/assets/img/placeholder.png'; console.error('Failed to load image');">
                <div class="variation-number">
                    V${choiceNum + 1}
                </div>
                <div class="image-actions">
                    <div class="dropdown">
                        <button class="fn__icon_button dropdown-toggle">
                            <img src="/static/assets/svg/download.svg" alt="" class="fn__svg">
                        </button>
                        <ul class="dropdown-menu dropdown-menu-dark">
                            <li class="dropdown-item" data-format="png" data-url="${imageUrl}">PNG</li>
                            <li class="dropdown-item" data-format="jpg" data-url="${imageUrl}">JPG</li>
                            <li class="dropdown-item" data-format="jpeg" data-url="${imageUrl}">JPEG</li>
                        </ul>
                    </div>
                </div>
            `;

            // Add click to enlarge
            const imgElement = imageContainer.querySelector('img');
            if (imgElement) {
                imgElement.addEventListener('click', () => {
                    showImageDetail(image, groupData.prompt);
                });
            }

            grid.appendChild(imageContainer);
        });
    } else {
        // If no images, show a message
        grid.innerHTML = '<div class="col-span-2 text-center py-4">No images available yet</div>';
    }

    container.appendChild(grid);

    // Replace existing content
    const imageDiv = document.getElementById('generated-image');
    imageDiv.innerHTML = '';
    imageDiv.appendChild(container);

    // Show download section
    document.getElementById('download-section').style.display = 'block';

    // Update state
    document.getElementById('generate-text').textContent = 'Générer une nouvelle image';

    // Update history
    loadHistory(1, false);
}


function updateProgressIndicator(percentage) {
    const progressBar = document.querySelector('.progress-bar');
    if (!progressBar) {
        const progressContainer = document.createElement('div');
        progressContainer.className = 'progress-container mt-4';
        progressContainer.innerHTML = `
            <div class="w-full bg-gray-200 rounded-full h-2.5">
                <div class="progress-bar bg-blue-600 h-2.5 rounded-full transition-all duration-500"
                     style="width: ${percentage}%"></div>
            </div>
            <div class="text-sm text-gray-600 mt-2">
                Génération en cours : ${Math.round(percentage)}%
            </div>
        `;
        document.getElementById('generated-image').appendChild(progressContainer);
    } else {
        progressBar.style.width = `${percentage}%`;
        progressBar.parentElement.nextElementSibling.textContent =
            `Génération en cours : ${Math.round(percentage)}%`;
    }
}
function showImageDetail(image, prompt) {
    // Get token for URLs
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');

    // Ensure we have a valid URL and choice number
    const imageUrl = image.url || '';
    const fullImageUrl = imageUrl.includes('token=') ? imageUrl :
        `${imageUrl}${imageUrl.includes('?') ? '&' : '?'}token=${encodeURIComponent(token)}`;

    const choiceNum = typeof image.choice === 'number' ? image.choice :
                     (typeof image.variation_number === 'number' ? image.variation_number : 0);

    const modal = document.createElement('div');
    modal.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50';
    modal.innerHTML = `
        <div class="bg-white w-full max-w-4xl rounded-lg p-4">
            <div class="flex justify-between items-center mb-4">
                <div>
                    <h3 class="text-xl font-semibold">Variation ${image.choice}</h3>
                    <p class="text-sm text-gray-600">${prompt}</p>
                </div>
                <button class="close-button text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <img src="${fullImageUrl}"
                 alt="Variation ${choiceNum + 1}"
                 class="w-full rounded-lg">
            <div class="mt-4 flex justify-between items-center">
                <div class="text-sm text-gray-600">
                    ${image.width || 1024}x${image.height || 1024}
                </div>
                <div class="dropdown">
                    <button class="fn__icon_button dropdown-toggle">
                        <img src="/static/assets/svg/download.svg" alt="" class="fn__svg">
                    </button>
                    <ul class="dropdown-menu dropdown-menu-dark">
                        <li class="dropdown-item" data-format="png" data-url="${fullImageUrl}">PNG</li>
                        <li class="dropdown-item" data-format="jpg" data-url="${fullImageUrl}">JPG</li>
                        <li class="dropdown-item" data-format="jpeg" data-url="${fullImageUrl}">JPEG</li>
                    </ul>
                </div>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    modal.querySelector('.close-button').addEventListener('click', () => {
        modal.remove();
    });

    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.remove();
        }
    });

    modal.addEventListener('click', (e) =>{
        if (e.target === modal) {
            modal.remove();
        }
    });
    // Set up download buttons
    modal.querySelectorAll('.dropdown-item').forEach(item => {
        item.addEventListener('click', (e) => {
            const format = e.target.getAttribute('data-format');
            const url = e.target.getAttribute('data-url');
            if (format && url) {
                downloadImage(url, format);
            }
        });
    });
}

function showErrorOverlay(title, message) {
    console.error(title, message);
    alert(`${title}: ${message}`);
}

    function saveInstance(prompt, imageUrl) {
        instances.push({ prompt, imageUrl });
    }

    // function addImageToSidebar(url, index) {
    //     const sidebar = document.getElementById('sidebar');
    //     const thumbnail = document.createElement('img');
    //     thumbnail.src = url;
    //     thumbnail.onclick = () => displayInstance(index);
    //     sidebar.insertBefore(thumbnail, sidebar.querySelector('.new-image').nextSibling);
    // }

    function addImageToSidebar(url, index) {
        const sidebar = document.getElementById('sidebar');

        const listItem = `
            <li class="fn__gl_item">
                <div class="fn__gl__item">
                    <div class="abs_item">
                        <img src="${url}" alt="Image ${index}" onclick="displayInstance(${index})">
                    </div>
                </div>
            </li>
        `;

        sidebar.innerHTML += listItem;
    }

    function displayInstance(index) {
        const { prompt, imageUrl } = instances[index];
        const promptInput = document.getElementById('prompt');
        const imageDiv = document.getElementById('generated-image');
        const downloadSection = document.querySelector('.fn__generation_item .item_list .fn__generation_list');

        promptInput.value = prompt;
        promptInput.disabled = true;
        imageDiv.innerHTML = `<img src="${imageUrl}" class="img-fluid mt-3" alt="Generated Image">`;
        downloadSection.style.display = 'block';
        generatedImageUrl = imageUrl;

        document.getElementById('generate-text').textContent = 'Générer une nouvelle image';

    }
    function createNewInstance() {
        document.getElementById('prompt').value = '';
        document.getElementById('prompt').disabled = false;
        document.getElementById('generated-image').innerHTML = '';
        document.getElementById('download-section').style.display = 'none';
        document.getElementById('generate-text').textContent = 'Générer l\'image';
    }
    function downloadImage(url, format) {
        console.error('Starting download:', {url, format});
        if (!url) {
            console.error('No URL provided for download');
            alert('URL de téléchargement manquante');
            return;
        }

        const img = new Image();
        img.crossOrigin = 'anonymous';

        // Add loading indicator
        const loadingIndicator = document.createElement('div');
        loadingIndicator.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
        loadingIndicator.innerHTML = `
            <div class="bg-white p-4 rounded">
                <div class="spinner-border" role="status"></div>
                <p class="mt-2">Téléchargement en cours...</p>
            </div>
        `;
        document.body.appendChild(loadingIndicator);

        img.onload = function () {
            console.error('Image loaded successfully');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            canvas.toBlob(function (blob) {
                loadingIndicator.remove();
                if (!blob) {
                    console.error('Failed to create blob');
                    alert('Échec de la création du fichier image');
                    return;
                }
                console.error('Blob created successfully');
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `image.${format.toLowerCase()}`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            }, `image/${format.toLowerCase()}`, 1.0);
        };
        // Gestion des erreurs
        img.onerror = function () {
            console.error('Erreur lors du chargement de l\'image');
            alert('Impossible de télécharger l\'image. Veuillez réessayer.');
        };

        // Set timeout to handle hanging requests
        setTimeout(() => {
            if (!img.complete) {
                loadingIndicator.remove();
                console.error('Image download timed out');
                alert('Le téléchargement a expiré. Veuillez réessayer.');
            }
        }, 20000);

        img.src = url;
    }

    function createHistoryItem(item, delay) {
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            const fullImageUrl = `${item.url}?token=${encodeURIComponent(token)}`;
            const listItem = document.createElement('li');
            listItem.className = 'fn__gl_item';

            if (item.model === 'midjourney' && item.images && item.images.length === 4) {
                // Créer un aperçu du groupe Midjourney
                listItem.innerHTML = `
                    <div class="fn__gl__item">
                        <div class="abs_item midjourney-group" data-group-id="${item.task_id}">
                            <div class="midjourney-group-preview">
                                ${item.images.map((img, index) => `
                                    <img src="${img.url}?token=${encodeURIComponent(token)}"
                                         alt="Variation ${index + 1}"
                                         loading="lazy">
                                `).join('')}
                            </div>
                            <div class="midjourney-group-overlay">
                                <span>Voir les 4 variations</span>
                            </div>
                            <div class="prompt">${item.prompt}</div>
                            <div class="timestamp">${new Date(item.timestamp).toLocaleString()}</div>
                        </div>
                    </div>
                `;
                // Gestionnaire d'événements pour l'ouverture du groupe
                listItem.querySelector('.midjourney-group').addEventListener('click', () => {
                    showMidjourneyDetail(item);
                });
            } else {
                listItem.innerHTML = `
                <div class="fn__gl__item">
                    <div class="abs_item">
                        <img src="${fullImageUrl}" alt="Generated image" loading="lazy">
                        <div class="prompt">${item.prompt}</div>
                        <div class="timestamp">${new Date(item.timestamp).toLocaleString()}</div>
                        <!-- Ajout du bouton de téléchargement similaire à celui des nouvelles images -->
                        <div class="all_options">
                            <div class="fn__icon_options medium_size">
                                <div class="dropdown">
                                    <button class="fn__icon_button dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                        <img src="/static/assets/svg/download.svg" alt="" class="fn__svg">
                                    </button>
                                    <ul class="dropdown-menu dropdown-menu-dark">
                                        <li class="dropdown-item" data-format="png" data-url="${fullImageUrl}">PNG</li>
                                        <li class="dropdown-item" data-format="jpg" data-url="${fullImageUrl}">JPG</li>
                                        <li class="dropdown-item" data-format="jpeg" data-url="${fullImageUrl}">JPEG</li>
                                        <li class="dropdown-item" data-format="gif" data-url="${fullImageUrl}">GIF</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;


            // Empêcher la propagation du clic pour les boutons de téléchargement
            const downloadButtons = listItem.querySelectorAll('.dropdown-item, .dropdown-toggle');
            downloadButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const format = button.getAttribute('data-format');
                    const imageUrl = button.getAttribute('data-url');
                    if (format && imageUrl) {
                        downloadImage(imageUrl, format);
                    }
                });
            });

            const img = listItem.querySelector('img');
            img.addEventListener('click', () => {
                const mainImageContainer = document.getElementById('generated-image');
                const downloadSection = document.getElementById('download-section');
                mainImageContainer.innerHTML = `<img src="${fullImageUrl}" class="img-fluid mt-3" alt="Generated Image">`;
                document.getElementById('prompt').value = item.prompt;
                downloadSection.style.display = 'block';
                generatedImageUrl = fullImageUrl;
            });

             // Ajouter le délai d'animation
            listItem.style.animationDelay = `${delay}ms`;

            }

            return listItem;

        }

        // Chargement automatique au scroll
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && hasMore && !isLoading) {
                    loadHistory(currentPage + 1, true);
                }
            });
        }, {
            rootMargin: '100px'
        });
        // Observer le loader
        observer.observe(document.getElementById('historyLoader'));

        // Chargement initial de l'historique
        //document.addEventListener('DOMContentLoaded', () => {
            //loadHistory(1, false);
        //});
    function showMidjourneyDetail(groupData) {
    const detailView = document.createElement('div');
    detailView.className = 'midjourney-detail-view';

    detailView.innerHTML = `
        <div class="midjourney-detail-content">
            <div class="detail-header">
                <h3>${groupData.prompt}</h3>
                <button class="close-button">×</button>
            </div>
            <div class="midjourney-variations-grid">
                ${groupData.images.map((img, index) => `
                    <div class="variation-item">
                        <img src="${img.url}?token=${encodeURIComponent(token)}"
                             alt="Variation ${index + 1}"
                             class="variation-image">
                        <div class="variation-number">V${index + 1}</div>
                        <div class="all_options">
                            <div class="fn__icon_options medium_size">
                                <div class="dropdown">
                                    <button class="fn__icon_button dropdown-toggle" type="button" data-bs-toggle="dropdown">
                                        <img src="/static/assets/svg/download.svg" alt="" class="fn__svg">
                                    </button>
                                    <ul class="dropdown-menu dropdown-menu-dark">
                                        <li class="dropdown-item" data-format="png" data-url="${img.url}">PNG</li>
                                        <li class="dropdown-item" data-format="jpg" data-url="${img.url}">JPG</li>
                                        <li class="dropdown-item" data-format="jpeg" data-url="${img.url}">JPEG</li>
                                        <li class="dropdown-item" data-format="gif" data-url="${img.url}">GIF</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;

    // Fermeture de la vue détaillée
    detailView.querySelector('.close-button').addEventListener('click', () => {
        detailView.remove();
    });

    // Clic sur l'arrière-plan pour fermer
    detailView.addEventListener('click', (e) => {
        if (e.target === detailView) {
            detailView.remove();
        }
    });

    document.body.appendChild(detailView);
}

    // Fonction pour charger l'historique
        async function loadHistory(page = 1, append = false) {
            console.error(`Fetching history for page ${page}...`);
            if (isLoading || (!append && !hasMore)) return;

            const historyLoader = document.getElementById('historyLoader');
            const historyContent = document.querySelector('.generation_history .fn__generation_list.sidebar');

            isLoading = true;
            historyLoader.classList.remove('d-none');

            try {
                const urlParams = new URLSearchParams(window.location.search);
                const token = urlParams.get('token');

                // Utiliser l'endpoint approprié pour votre historique
                const endpoint = '/api/chat/history/generated';
                const url = `${endpoint}?page=${page}&token=${encodeURIComponent(token)}`;

                const response = await fetch(url, {
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });

                if (!response.ok) {
                    if (response.status === 401 || response.status === 403) {
                        window.location.href = LOGIN_URL;
                        return;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.error('Fetched data:', data);

                if (!append) {
                    historyContent.innerHTML = '';
                }

                const items = data.data?.items || [];

                if (items.length > 0) {
                    items.forEach((item, index) => {
                        console.error('Processing item:', {
                            index,
                            rawItem: item,
                            modelFromParams: item.parameters?.model,
                            url: item.url,
                            imageUrl: item.image_url, // Au cas où l'URL serait sous un nom différent
                            prompt: item.prompt,
                            timestamp: item.timestamp
                        });
                       // Normaliser les données selon le modèle
                        const normalizedItem = {
                            url: item.url || item.image_url,
                            prompt: item.prompt,
                            timestamp: item.timestamp,
                            model: item.model || currentModel // Utiliser le modèle courant si non spécifié
                        };

                        // Vérifier que nous avons une URL valide
                        if (!normalizedItem.url) {
                            console.error('Missing URL for item:', normalizedItem);
                            return; // Skip this item
                        }

                        const delay = index * 100;
                        const historyItem = createHistoryItem(normalizedItem, delay);
                        historyContent.appendChild(historyItem);
                    });

                    hasMore = data.data?.pagination?.has_more || false;
                    currentPage = page;

                    // Gestion du bouton "Charger plus"
                    if (hasMore) {
                        if (!document.getElementById('loadMoreBtn')) {
                            const loadMoreBtn = document.createElement('button');
                            loadMoreBtn.id = 'loadMoreBtn';
                            loadMoreBtn.className = 'load-more';
                            loadMoreBtn.textContent = 'Charger plus';
                            loadMoreBtn.onclick = () => loadHistory(currentPage + 1, true);
                            historyContent.after(loadMoreBtn);
                        }
                    } else {
                        const loadMoreBtn = document.getElementById('loadMoreBtn');
                        if (loadMoreBtn) loadMoreBtn.remove();
                    }
                } else {
                    if (!append) {
                        historyContent.innerHTML = '<p class="text-center">Aucun historique disponible</p>';
                    }
                    hasMore = false;
                }

            } catch (error) {
                console.error('Error loading history:', error);
                if (!append) {
                    historyContent.innerHTML = '<p class="text-center text-danger">Erreur lors du chargement de l\'historique</p>';
                }
            } finally {
                isLoading = false;
                historyLoader.classList.add('d-none');
            }
        }
        async function validateImageUrl(imageUrl, token) {
            try {
                const fullUrl = `${imageUrl}?token=${encodeURIComponent(token)}`;
                const response = await fetch(fullUrl, { method: 'HEAD' });

                if (!response.ok) {
                    console.error('Debug - Image validation failed:', response.status);
                    return false;
                }

                const contentType = response.headers.get('content-type');
                return contentType && contentType.startsWith('image/');
            } catch (error) {
                console.error('Debug - Image validation error:', error);
                return false;
            }
        }


        document.addEventListener('DOMContentLoaded', function() {
            // Récupérer le token de l'URL actuelle
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');

            if (token) {
                // Modifier tous les liens de navigation pour inclure le token
                document.querySelectorAll('.neltar_fn_wrapper a').forEach(link => {
                    // Vérifier si c'est un lien interne
                    if (link.href.startsWith(window.location.origin)) {
                        const url = new URL(link.href);
                        url.searchParams.set('token', token);
                        link.href = url.toString();
                    }
                });
                // Modifier tous les formulaires pour inclure le token
                document.querySelectorAll('form').forEach(form => {
                    const input = document.createElement('input');
                    input.type = 'hidden';
                    input.name = 'token';
                    input.value = token;
                    form.appendChild(input);
                });
            }

            document.addEventListener('click', function(event) {
                const dropdownItem = event.target.closest('.dropdown-item');
                if (dropdownItem) {
                    const format = dropdownItem.getAttribute('data-format');
                    const imageUrl = dropdownItem.getAttribute('data-url') || generatedImageUrl;

                    console.log('Download clicked:', {format, imageUrl});

                    if (format && imageUrl) {
                        downloadImage(imageUrl, format);
                        // Fermer le dropdown après la sélection
                        const dropdownMenu = dropdownItem.closest('.dropdown-menu');
                        if (dropdownMenu) {
                            dropdownMenu.classList.remove('show');
                        }
                    }
                }
            });

            // Intercepter fetch pour les  erreurs d'authentification
            fetch = (originalFetch => {
                return async (...arguments) => {
                    try {
                        const response = await originalFetch(...arguments);
                        if (response.status === 401 || response.status === 403) {
                            const data = await response.json();
                            if (data.redirect_url) {
                                window.location.href = data.redirect_url;
                                return;
                            }
                        }
                        return response;
                    } catch (error) {
                        throw error;
                    }
                };
            })(fetch);

            loadHistory(1, false);
        });
</script>




{% endblock %}
