{% extends 'base.html' %}

{% block title %}Home Page{% endblock %}

{% block content %}

<style>
    .midjourney-enhanced-container {
        position: relative;
        width: 100%;
        max-width: 1100px;
        margin: 0 auto 20px;
        background-color: #18191d;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .midjourney-header {
        padding: 16px 20px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .midjourney-prompt {
        flex: 1;
        overflow: hidden;
    }

    .midjourney-prompt h3 {
        font-size: 16px;
        font-weight: 600;
        color: #ffffff;
        margin: 0 0 4px 0;
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
    }

    .midjourney-prompt div {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.5);
    }

    .midjourney-close-btn {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        border: none;
        background-color: rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.7);
        font-size: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        margin-left: 10px;
    }

    .midjourney-close-btn:hover {
        background-color: rgba(255, 255, 255, 0.2);
        color: rgba(255, 255, 255, 0.9);
    }

    .midjourney-image-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        padding: 8px;
    }

    .midjourney-image-card {
        position: relative;
        border-radius: 8px;
        overflow: hidden;
        background-color: #22232a;
        aspect-ratio: 1;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .midjourney-image-card:hover {
        transform: scale(1.02);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .midjourney-image-card img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
        transition: transform 0.3s ease;
    }

    .midjourney-image-card:hover img {
        transform: scale(1.05);
    }

    .version-badge {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.75);
        color: #fff;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.5px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        z-index: 1;
    }

    .image-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0);
        transition: background-color 0.3s ease;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: flex-end;
        padding: 10px;
        box-sizing: border-box;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .midjourney-image-card:hover .image-overlay {
        background-color: rgba(0, 0, 0, 0.2);
        opacity: 1;
    }

    .download-container {
        position: relative;
        z-index: 2;
    }

    .download-button {
        background-color: rgba(0, 0, 0, 0.75);
        border: none;
        border-radius: 4px;
        color: #fff;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        transition: background-color 0.2s ease;
    }

    .download-button:hover {
        background-color: rgba(0, 0, 0, 0.9);
    }

    .format-dropdown {
        position: absolute;
        top: 100%;
        right: 0;
        margin-top: 5px;
        background-color: #2a2b31;
        border-radius: 4px;
        overflow: hidden;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        display: none;
        z-index: 3;
    }

    .format-option {
        padding: 8px 16px;
        cursor: pointer;
        color: #fff;
        transition: background-color 0.2s ease;
        font-size: 12px;
    }

    .format-option:hover {
        background-color: #3a3b42;
    }

    .success-message {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 12px;
        background-color: rgba(0, 200, 83, 0.15);
        color: #00c853;
        border-top: 1px solid rgba(0, 200, 83, 0.2);
        overflow: hidden;
        transition: all 0.5s ease-out;
    }

    .success-message svg {
        margin-right: 8px;
    }

    /* Lightbox styles */
    .midjourney-lightbox {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .midjourney-group {
        position: relative;
        width: 100%;
        max-width: 400px;
        cursor: pointer;
    }

    .midjourney-group-preview {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 2px;
        border-radius: 8px;
        overflow: hidden;
    }

    .midjourney-group-preview img {
        width: 100%;
        height: auto;
        object-fit: cover;
    }

    .midjourney-group-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .midjourney-group:hover .midjourney-group-overlay {
        opacity: 1;
    }

    .midjourney-detail-view {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.9);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .midjourney-detail-content {
        width: 90%;
        max-width: 1200px;
        background: #fff;
        border-radius: 12px;
        padding: 20px;
    }

    .midjourney-variations-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 16px;
        margin-top: 20px;
    }

    .variation-item {
        position: relative;
        cursor: pointer;
        transition: transform 0.2s;
    }

    .variation-item:hover {
        transform: scale(1.02);
    }

    .variation-number {
        position: absolute;
        bottom: 8px;
        left: 8px;
        background: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
    }
     .spinner-border {
            width: 2rem;
            height: 2rem;
            color: #333;
            margin-top: 20px;
            display: none;
        }

    .dropdown-item{
        cursor: pointer
    }
    #download-section {
            display: none;
        }
    .midjourney-group-container {
        @apply p-4;
    }

    .progress-container {
        @apply mt-4 mb-8;
    }

    .variation-number {
        @apply absolute bottom-2 left-2 bg-black bg-opacity-50 text-white px-2 py-1 rounded text-sm;
    }

    .image-actions {
        @apply absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity;
    }
    .generation-status {
        padding: 2rem;
        text-align: center;
    }

    .initial-grid {
        position: relative;
        overflow: hidden;
        border-radius: 0.5rem;
        margin-bottom: 2rem;
    }

    .initial-grid img {
        width: 100%;
        height: auto;
    }

    #upscale-progress {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 1rem;
        margin-top: 2rem;
    }

    .upscale-slot {
        position: relative;
        aspect-ratio: 1/1;
        background: #f3f4f6;
        border-radius: 0.5rem;
        overflow: hidden;
    }

    .progress-container {
        width: 100%;
        height: 4px;
        background: #e5e7eb;
        border-radius: 2px;
        overflow: hidden;
    }

    .progress-bar {
        height: 100%;
        background: #3b82f6;
        transition: width 0.3s ease;
    }
    @keyframes tokenChange {
        0% { transform: scale(1); }
        50% { transform: scale(1.2); color: #00c853; }
        100% { transform: scale(1); }
    }

    .token-change {
        animation: tokenChange 0.5s ease-in-out;
    }

    .tokens-info {
        margin-right: 10px;
        color: rgba(255, 255, 255, 0.7);
        font-size: 14px;
    }

    .tokens-count {
        font-weight: bold;
        color: #fff;
    }

    .error-message {
        margin: 15px 0;
        display: none;
        border-radius: 8px;
        overflow: hidden;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        background-color: #fff;
        border-left: 4px solid #f44336;
        animation: fadeIn 0.3s ease-in-out;
    }

    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(-10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    .token-error-content {
        display: flex;
        padding: 16px;
        align-items: flex-start;
    }

    .token-error-icon {
        font-size: 24px;
        margin-right: 16px;
        line-height: 1;
    }

    .token-error-message {
        flex: 1;
    }

    .token-error-message strong {
        display: block;
        margin-bottom: 8px;
        font-size: 16px;
        color: #f44336;
    }

    .token-error-message p {
        margin: 0 0 10px 0;
        color: #555;
    }

    .token-count, .token-required {
        font-weight: bold;
        color: #333;
    }

    .token-upgrade-link {
        display: inline-block;
        margin-top: 5px;
        padding: 5px 10px;
        background-color: #4CAF50;
        color: white;
        text-decoration: none;
        border-radius: 4px;
        font-size: 14px;
        transition: background-color 0.2s;
    }

    .token-upgrade-link:hover {
        background-color: #3e8e41;
    }

    .token-error-close {
        background: none;
        border: none;
        font-size: 20px;
        color: #aaa;
        cursor: pointer;
        padding: 0 5px;
    }

    .token-error-close:hover {
        color: #555;
    }
</style>
<div class="neltar_fn_page">

    <!-- Image Generation Page -->
    <div class="neltar_fn_image_generation_page">

        <div class="generation__page">

            <!-- Generation Header -->
            <div class="generation_header">
                <div class="header_top">
                    <h1 class="title">Image Generation</h1>
                    <div class="setup">
                        <p class="info">This wil use <span class="token-cost" data-model="dall-e">20</span> tokens</p>
                        <div class="token-info">
                            <span class="token_summary">
                                <span class="count">--</span>
                                <span class="text">Tokens<br>Remain</span>
                            </span>
                            <a href="pricing.html" class="token_upgrade neltar_fn_button"><span>Upgrade</span></a>
                            <div class="token__popup">
                                Resets in <span>--</span><br>
                                Daily limit is <span>--</span>
                            </div>
                        </div>
                        <a href="#" class="sidebar__trigger">
                            <img src="{{ url_for('static', filename='assets/svg/option.svg') }}" alt="" class="fn__svg">
                        </a>
                    </div>
                </div>
                <div class="header_bottom">
                    <form id="generate-image-form">

                    <div class="include_area">
                        <textarea  id="prompt" placeholder="Entrez une description" required rows="1"></textarea>

                    </div>

                    <div class="generate_section">

                        <button type="submit" id="generate_it" href="#" class="neltar_fn_button btn btn-link">
                            <span id="generate-text">Générer l'image</span>
                            <div class="spinner-border" id="spinner" role="status"></div>
                        </button>
                    </div>
                </form>
                <div id="token-error" class="error-message alert alert-danger" style="display: none;"></div>

                </div>


            </div>

            <div class="generation_history"  id="download-section">

                <!-- Ajoutez ces éléments dans  HTML -->

                <div id="historyLoader" class="text-center d-none">
                    <div class="spinner-border" role="status">
                        <span class="sr-only">Chargement...</span>
                    </div>
                </div>
                <div id="historyContent" class="fn__generation_list">
                    <!-- L'historique sera chargé ici -->
                </div>

                <div class="fn__generation_item">

                    <div class="item_list">
                        <ul class="fn__generation_list" style="justify-content: center;">
                            <li class="fn__gl_item" style="width: 400px;">
                                <div class="fn__gl__item">

                                    <div class="abs_item">

                                        <div id="generated-image">
                                            <!-- <img src="{{ url_for('static', filename='assets/img/gallery/1.jpg') }}" alt=""> -->

                                        </div>
                                        <div class="all_options">
                                            <div class="fn__icon_options medium_size">

                                                <div class="dropdown">
                                                    <button class="fn__icon_button dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                                        <img src="{{ url_for('static', filename='assets/svg/download.svg') }}" alt="" class="fn__svg">
                                                    </button>
                                                    <ul class="dropdown-menu dropdown-menu-dark">

                                                      <li class="dropdown-item" data-format="png">PNG</li>
                                                      <li class="dropdown-item" data-format="jpg">JPG</li>
                                                      <li class="dropdown-item" data-format="jpeg">JPEG</li>
                                                      <li class="dropdown-item" data-format="gif">GIF</li>

                                                    </ul>
                                                  </div>
                                            </div>

                                        </div>
                                    </div>
                                </div>
                            </li>

                        </ul>
                    </div>

                </div>

            </div>

            <div class="generation_history">

                <div class="fn__generation_item">
                    <div class="item_header">
                        <div class="title_holder">
                            <h2 class="prompt_title">Images History</h2>
                        </div>
                        <div class="item_options">
                            <div class="fn__icon_options medium_size align_right">
                                <a href="javascript:;" class="fn__icon_button" onclick="createNewInstance()">
                                    <img src="{{ url_for('static', filename='assets/svg/plus.svg') }}" alt="" class="fn__svg">
                                </a>

                            </div>

                        </div>
                    </div>
                    <div class="item_list">
                        <ul class="fn__generation_list sidebar" id="sidebar">

                            <!-- <li class="fn__gl_item">
                                <div class="fn__gl__item">
                                    <div class="abs_item">
                                            <img src="img/gallery/1.jpg" alt="">
                                    </div>
                                </div>
                            </li> -->


                        </ul>
                    </div>
                </div>

            </div>

        </div>

        <div class="generation__sidebar">
            <div class="sidebar_model">
                <div class="fn__select_model">
                    <a class="model_open">
                        <img class="user_img" src="{{ url_for('static', filename='assets/img/user/user.jpg') }}" alt="">
                        <div class="author">
                            <h4 class="subtitle">Model</h4>
                            <h3 class="title">GPT 4o</h3>
                        </div>
                        <span class="fn__icon_button">
                            <img src="{{ url_for('static', filename='assets/svg/arrow.svg') }}" alt="" class="fn__svg">
                        </span>
                    </a>
                    <div class="all_models">
                        <ul>
                            <li><a class="selected" href="#">GPT 4o</a></li>
                            <li><a href="#">Midjourney</a></li>

                        </ul>
                    </div>
                </div>
            </div>
            <div class="sidebar_details">
                <div class="aspect_ratio">
                    <h4 class="title">Image Format</h4>
                    <div class="ratio_select">
                        <select id="aspect-ratio-select">
                            <option value="">Format par défaut</option>
                            <option value="1:1">Carré (1:1)</option>
                            <option value="16:9">Paysage (16:9)</option>
                            <option value="9:16">TikTok (9:16)</option>
                            <option value="4:3">Standard (4:3)</option>
                            <option value="3:4">Portrait Standard (3:4)</option>
                            <option value="2:1">Panoramique (2:1)</option>
                            <option value="3:2">Photo (3:2)</option>
                        </select>
                    </div>
                </div>
                <div class="aspect-ratio-preview">
                    <div id="ratio-preview-box" style="position: relative; width: 100%; height: 100px; background-color: #444; border-radius: 4px; display: flex; align-items: center; justify-content: center; margin-top: 10px;">
                        <div id="ratio-preview-inner" style="width: 80%; height: 80%; background-color: #777; border-radius: 2px;"></div>
                    </div>
                </div>
                <!-- Style Selector -->
                <div class="style_selector">
                    <h4 class="title">Style visuel</h4>
                    <div class="style_select">
                        <select id="style-select">
                            <option value="">Style par défaut</option>
                            <option value="raw">Brut (Raw)</option>
                            <option value="cute">Mignon (Cute)</option>
                            <option value="scenic">Paysage (Scenic)</option>
                            <option value="expressive">Expressif (Expressive)</option>
                        </select>
                    </div>
                </div>

                <!-- Medium Selector -->
                <div class="medium_selector">
                    <h4 class="title">Médium artistique</h4>
                    <div class="medium_select">
                        <select id="medium-select">
                            <option value="">Aucun médium spécifique</option>
                            <option value="digital">Art digital</option>
                            <option value="traditional">Peinture traditionnelle</option>
                            <option value="drawing">Dessin</option>
                            <option value="print">Impression artistique</option>
                            <option value="photographic">Photographique</option>
                        </select>
                    </div>
                </div>

                <!-- Chaos Level -->
                <div class="chaos_level">
                    <h4 class="title">Niveau de créativité</h4>
                    <div class="fn__range">
                        <div class="range_in">
                            <input type="range" id="chaos-slider" min="0" max="100" value="0" step="10">
                            <div class="slider"></div>
                        </div>
                        <div class="value" id="chaos-value">0</div>
                    </div>
                </div>

                <!-- Seed Input -->
                <div class="seed_input">
                    <h4 class="title">Seed (génération reproductible)<span class="fn__tooltip" title="Utiliser la même seed permet de reproduire des résultats similaires."><img src="{{ url_for('static', filename='assets/svg/question.svg') }}" alt="" class="fn__svg"></span></h4>
                    <div class="fn__text_field">
                        <input type="number" id="seed-input" placeholder="Laisser vide pour aléatoire">
                    </div>
                </div>

                <!-- Advanced Options -->
                <div class="prompt_options">
                    <h4 class="title">Options avancées</h4>

                    <!-- Quality Selection -->
                    <div class="quality_option">
                        <label for="quality_select">Qualité :</label>
                        <select id="quality-select">
                            <option value="2">Haute qualité (2)</option>
                            <option value="1">Standard (1)</option>
                        </select>
                    </div>

                    <!-- Checkboxes for Other Options -->
                    <div class="option_checkboxes">
                        <label class="fn__toggle">
                            <span class="t_in">
                                <input type="checkbox" id="enhance-details">
                                <span class="t_slider"></span>
                                <span class="t_content"></span>
                            </span>
                            <span class="option_label">Ajouter détails HD</span>
                        </label>

                        <label class="fn__toggle">
                            <span class="t_in">
                                <input type="checkbox" id="photorealistic">
                                <span class="t_slider"></span>
                                <span class="t_content"></span>
                            </span>
                            <span class="option_label">Photoréaliste</span>
                        </label>

                        <label class="fn__toggle">
                            <span class="t_in">
                                <input type="checkbox" id="no-text">
                                <span class="t_slider"></span>
                                <span class="t_content"></span>
                            </span>
                            <span class="option_label">Sans texte</span>
                        </label>
                    </div>
                </div>

                <!-- Version Selector -->
                <div class="version_selector">
                    <h4 class="title">Version du modèle</h4>
                    <div class="version_select">
                        <select id="version-select">
                            <option value="6.0">Version 6.0 (défaut)</option>
                            <option value="5.2">Version 5.2</option>
                            <option value="5.1">Version 5.1</option>
                            <option value="5.0">Version 5.0</option>
                            <option value="niji">Niji 5 (style anime)</option>
                        </select>
                    </div>
                </div>
            </div>
                <div class="guidance_scale">
                    <h4 class="title">Image Dimensions<span class="fn__tooltip" title="Select the resoultion of the images."><img src="{{ url_for('static', filename='assets/svg/question.svg') }}" alt="" class="fn__svg"></span></h4>
                    <div class="fn__range">
                        <div class="range_in">
                            <input type="range" min="1" max="40" value="7">
                            <div class="slider"></div>
                        </div>
                        <div class="value">7</div>
                    </div>
                </div>
                <div class="prompt_magic_switcher">
                    <h4 class="title"><label for="prompt_switcher">Prompt Magic</label><span class="fn__tooltip" title="TechWave Prompt v3.0. Our custom render pipeline which has much faster compliance and can improve the result with any model selected. Applies a 2x multiplier to accepted costs due to higher GPU overhead."><img src="{{ url_for('static', filename='assets/svg/question.svg') }}" alt="" class="fn__svg"></span></h4>
                    <label class="fn__toggle">
                        <span class="t_in">
                            <input type="checkbox" checked="" id="prompt_switcher">
                            <span class="t_slider"></span>
                            <span class="t_content"></span>
                        </span>
                    </label>
                </div>
                <div class="contrast_switcher">
                    <h4 class="title"><label for="contrast_switcher">High Contrast</label><span class="fn__tooltip" title="If your photo consists of extremely bright and dark areas, then it's considered high contrast. When it has a wide range of tones that go from pure white to pure black, it's medium contrast. No pure whites or blacks and a range of middle tones means it's low contrast."><img src="{{ url_for('static', filename='assets/svg/question.svg') }}" alt="" class="fn__svg"></span></h4>
                    <label class="fn__toggle">
                        <span class="t_in">
                            <input type="checkbox" id="contrast_switcher">
                            <span class="t_slider"></span>
                            <span class="t_content"></span>
                        </span>
                    </label>
                </div>
            </div>
        </div>


    </div>
    <!-- !Image Generation Page -->

</div>

<script>
const LOGIN_URL = "{{ LOGIN_URL }}";

    document.querySelectorAll('.neltar_fn_wrapper').forEach(element => {
    element.classList.add('fn__has_sidebar');
});

    let currentModel = 'dall-e';
    let generatedImageUrl = '';
    const instances = [];

    //ajout supplémentaire !
    let currentPage = 1;
    let isLoading = false;
    let hasMore = true;

    // Écouteur pour le changement de modèle
    document.querySelectorAll('.all_models a').forEach(modelLink => {
        modelLink.addEventListener('click', function(e) {
            e.preventDefault();
            const modelName = this.textContent.toLowerCase();
            currentModel = modelName.includes('gpt') ? 'dall-e' : 'midjourney';
            console.error('model en question:', modelName)

            // Mise à jour visuelle
            document.querySelectorAll('.all_models a').forEach(link => {
                link.classList.remove('selected');
            });
            this.classList.add('selected');

            // Mise à jour du titre affiché
            document.querySelector('.model_open .title').textContent = this.textContent;
        });
    });

    document.getElementById('generate-image-form').addEventListener('submit', async function(event) {
        event.preventDefault();
        const promptInput = document.getElementById('prompt');
        const promptText = promptInput.value;
        const spinner = document.getElementById('spinner');
        const generateText = document.getElementById('generate-text');
        const downloadSection = document.querySelector('.fn__generation_item .item_list .fn__generation_list');
        const imageDiv = document.getElementById('generated-image');
        console.error('Elements exists:', {
            imageDiv: !!imageDiv,
            downloadSection: !! downloadSection
        });

        console.error('Current Model:', currentModel);
        console.error('Prompt:', promptInput.value);

        // Get the token from URL
        const urlParams = new URLSearchParams(window.location.search);
        const token = urlParams.get('token');

        if (!token) {
        showErrorOverlay('Erreur', 'Session invalide. Veuillez vous reconnecter.');
        setTimeout(() => {
            window.location.href = LOGIN_URL;
        }, 2000);
        return;
    }

        promptInput.disabled = true;
        spinner.style.display = 'inline-block';
        generateText.style.display = 'none';
        downloadSection.style.display = 'none';

        // Suppression de tout message d'erreur précédent
        const existingError = document.querySelector('.token-error-box');
        if (existingError) {
            existingError.remove();
        }

        try {
            updateLoadingState('loading');
            // Construction de la requête
            const requestOptions = {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                body: `prompt=${encodeURIComponent(promptText)}&model=${encodeURIComponent(currentModel)}`
            };

            console.log('Sending request with options:', requestOptions);

            // Envoi de la requête au backend
            const response = await fetch(`/generate_image?token=${encodeURIComponent(token)}`, requestOptions);

            // Traitement de la réponse
            console.log('Response status:', response.status);

            // Analyse du corps JSON (pour tout type de statut)
            const result = await response.json();
            console.log('Response data:', result);

            // Gestion spécifique des tokens insuffisants (maintenant avec code 200)
            if (result.error === "Insufficient tokens") {
                const modal = displayTokenError(result.tokens_available, result.tokens_required)
                // Analyse pour suggérer le bon forfait
                const tokenShortage = result.tokens_required - result.tokens_available;

                // Mettre en évidence le plan suggéré sur la base du manque de tokens
                if (tokenShortage > 500) {
                    // Utilisateur a besoin de beaucoup de tokens, suggérer le plan Pro
                    modal.querySelector('.token-message').innerHTML += `<br><strong class="plan-suggestion">Notre forfait Pro vous conviendrait parfaitement!</strong>`;
                } else if (tokenShortage > 100) {
                    // Utilisateur a besoin d'un nombre moyen de tokens, suggérer le plan Premium
                    modal.querySelector('.token-message').innerHTML += `<br><strong class="plan-suggestion">Notre forfait Premium semble fait pour vous!</strong>`;
                }

                updateLoadingState('default');
                return;
            }

            // Gestion des autres types d'erreurs
            if (!result.success) {
                console.error('Error in response:', result.error || 'Unknown error');
                showErrorOverlay('Erreur', result.message || result.error || 'Une erreur est survenue');
                updateLoadingState('default');
                return;
            }

            // Traitement des succès
            console.log('Success response:', result);

            // Cas spécial pour Midjourney (traitement asynchrone)
            if (currentModel === 'midjourney' && result.status === 'processing') {
                console.log('Starting Midjourney processing with task_id:', result.task_id);
                updateLoadingState('processing');
                displayInitialLoadingState();
                handleMidjourneyProcessing(result.task_id, token, promptText);
            } else {
                // Cas DALL-E ou autre réponse immédiate
                console.log('Displaying generated image:', result.image_url);
                displayGeneratedImage(result.image_url);

                // Mise à jour explicite des tokens si disponible
                if (result.tokens_remaining !== undefined) {
                    console.log('Updating tokens display to:', result.tokens_remaining);
                    updateTokensUI(result.tokens_remaining);
                } else {
                    // Sinon, rafraîchir les tokens via l'API
                    updateTokensDisplay();
                }

                // Mettre à jour le texte du bouton
                generateText.textContent = 'Générer une nouvelle image';
            }
        } catch (error) {
            console.error('Error in fetch operation:', error);
            showErrorOverlay('Erreur', 'Impossible de contacter le serveur. Veuillez réessayer plus tard.');
        } finally {
            // Réinitialisation de l'interface
            spinner.style.display = 'none';
            generateText.style.display = 'inline';
            promptInput.disabled = false;
        }
    });
    const extraStyles = `
                .plan-suggestion {
                    display: block;
                    margin-top: 10px;
                    color: #8e78ff;
                    font-size: 16px;
                    animation: highlight 2s infinite;
                }

                @keyframes highlight {
                    0% { color: #8e78ff; }
                    50% { color: #ffffff; }
                    100% { color: #8e78ff; }
                }

                /* Style pour rendre le modal de tokens plus visible */
                .token-upgrade-modal::before {
                    content: '';
                    position: fixed;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: radial-gradient(circle at center, transparent 20%, rgba(0,0,0,0.8) 100%);
                    pointer-events: none;
                }

                /* Optimisations pour l'interface tokens en haut de page */
                .token-count-wrapper {
                    display: flex;
                    align-items: center;
                    gap: 10px;
                }

                .tokens-remain {
                    font-weight: bold;
                    color: #fff;
                    background: rgba(0,0,0,0.2);
                    padding: 4px 8px;
                    border-radius: 4px;
                    transition: all 0.3s;
                }

                .token-refresh-info {
                    font-size: 12px;
                    color: rgba(255,255,255,0.7);
                    margin-top: 3px;
                }
            `;


    // Fonction de gestion du traitement Midjourney
async function handleMidjourneyProcessing(taskId, token) {
    console.error('=== Starting Midjourney Polling ===');
    console.error('Task ID:', taskId);
    const generateText = document.getElementById('generate-text');
    generateText.textContent = 'Génération en cours...';

    const generateButton = document.getElementById('generate_it');
    if (generateButton) {
        generateButton.classList.add('processing-pulse');
    }
    // Déduire immédiatement les tokens pour feedback instantané
    updateTokenCost();
    const tokenCostElement = document.querySelector('.token-cost');
    const tokenCost = parseInt(tokenCostElement ? tokenCostElement.textContent : 30);

    // Récupérer la valeur actuelle des tokens et les mettre à jour visuellement
    const tokenCount = document.querySelector('.token_summary .count');
    if (tokenCount) {
        const currentTokens = parseInt(tokenCount.textContent);
        if (!isNaN(currentTokens) && !isNaN(tokenCost)) {
            const newTokens = Math.max(0, currentTokens - tokenCost);
            // Mise à jour visuelle immédiate
            updateTokensUI(newTokens);
        }
    }

    let lastImagesCount = 0;
    const maxAttempts = 30;
    let attempts = 0;

    displayInitialLoadingState();
    updateLoadingState('processing');
    updateProgressIndicator(5);

    while (attempts < maxAttempts) {
        console.error(`Polling attempt ${attempts + 1}/${maxAttempts}`);
        try {
            console.error('Sending request with model:', currentModel);
            // Ajouter un timeout à la requête fetch
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 secondes

            const statusResponse = await fetch(`/check_midjourney_status/${taskId}?token=${encodeURIComponent(token)}`, {
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                },
                signal: controller.signal
            });

            clearTimeout(timeoutId)
            console.error('Status response:', statusResponse.status);

            // Ajoutez ces logs pour déboguer
            console.error(`Requested URL: /check_midjourney_status/${taskId}?token=[redacted]`);
            console.error(`taskId value: ${taskId}`);
            console.error(`taskId type: ${typeof taskId}`);

            if (!statusResponse.ok) {
                console.error(`Response not OK: ${statusResponse.status}`);
                // Tenter de lire le corps de la réponse pour plus d'informations
                try {
                    const errorText = await statusResponse.text();
                    console.error(`Error response body: ${errorText}`);
                } catch (readError) {
                    console.error(`Could not read error response: ${readError}`);
                }
                throw new Error('Erreur lors de la vérification du statut');
            }

            const statusResult = await statusResponse.json();
            console.error('Status data:', statusResult);

            // Mise à jour de la progression si disponible
            if (statusResult.success && statusResult.data) {
                const data = statusResult.data;

                // Si nous avons la grille initiale, l'afficher
                if (data.initial_grid && !document.querySelector('.initial-grid')) {
                    displayInitialGrid(data.initial_grid);
                }

                // Mettre à jour la progression des upscales
                if (data.images && Array.isArray(data.images) && data.images.length > lastImagesCount) {
                    // Check if we have new images to show progress
                    if (data.images.length > lastImagesCount) {
                        lastImagesCount = data.images.length;
                        updateUpscaleProgress(data.images);

                        // Augmenter la progression en fonction du nombre d'images reçues
                        const progressPercentage = Math.min(80, 20 + (data.images.length / 4) * 60);
                        updateProgressIndicator(progressPercentage);
                    }
                }

                // Si le groupe est complet
                if ((data.status === 'completed' || data.group_status ==='completed') && (data.images && data.images.length >=4)) {
                    console.error('Group complete, displaying results');
                    displayMidjourneyGroup(data);
                    console.error('call displayMidjourneyGroup');
                    updateLoadingState('complete');

                    if (generateButton) {
                        generateButton.classList.remove('processing-pulse');
                    }
                    updateProgressIndicator(100);
                    return;
                } else if (data.images && data.images.length >=4) {
                    // If we have all 4 images but status isn't marked complete, show them anyway
                    console.error('All 4 images received, displaying anyway');
                    displayMidjourneyGroup(data);
                    updateLoadingState('complete');
                    if (generateButton) {
                        generateButton.classList.remove('processing-pulse');
                    }
                    updateProgressIndicator(100);
                    return;
                }

                // Mettre à jour la barre de progression
                const progress = Math.min(90, 20 + (attempts / maxAttempts) * 70);
                updateProgressIndicator(progress);
            }

            // Gestion des erreurs spécifiques
            if (statusResult.status === 'failed' || statusResult.data?.status === 'failed') {
                showErrorOverlay('Erreur', 'La génération a échoué');
                updateLoadingState('default');

                if (generateButton) {
                    generateButton.classList.remove('processing-pulse');
                }
                return;
            }

            const delay = attempts < 5 ? 5000 : 10000;
            await new Promise(resolve => setTimeout(resolve, delay));
            attempts++;

        } catch (error) {
            console.error('Error in polling:', error);
            if (attempts === maxAttempts - 1) {
                showErrorOverlay('Erreur', 'Erreur lors de la vérification du statut');
                updateLoadingState('default');
                if (generateButton) {
                    generateButton.classList.remove('processing-pulse');
                }
                return;
            }
            await new Promise(resolve => setTimeout(resolve, 2000));
            attempts++;
        }
    }

    showErrorOverlay('Erreur', 'Le délai de génération a été dépassé');
    updateLoadingState('default');
    if (generateButton) {
        generateButton.classList.remove('processing-pulse');
    }
}

// Fonction d'affichage de l'image générée
function displayGeneratedImage(imageUrl, isGroup = false) {
    if (isGroup) {
        // Pour les groupes Midjourney, attendre que toutes les images soient générées
        return;
    }
    console.error('Starting displayGeneratedImage with imageUrl:', imageUrl);

    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');
    console.error('Token retrieved:', token ? 'Token found' : 'No token');

    const fullImageUrl = `${imageUrl}?token=${encodeURIComponent(token)}`;
    console.error('Full image URL constructed:', fullImageUrl);

    generatedImageUrl = fullImageUrl;
    const imageDiv = document.getElementById('generated-image');
    console.error('Image div found:', imageDiv ? 'Yes' : 'No');

    // Utiliser le bon sélecteur pour cibler la liste qui contient l'image
    const downloadSection = document.getElementById('download-section');
    const imageContainer = document.querySelector('.fn__generation_item .item_list .fn__generation_list');

    console.error('Containers found:', {
        imageDiv: !!imageDiv,
        imageContainer: !!imageContainer,
        downloadSection: !!downloadSection
    });


    if (!imageDiv || !downloadSection || !imageContainer) {
        console.error('Image container missing');
        return;
    }
    const newImage = new Image();
    newImage.onload = function () {
        console.error('Test image loaded successfully');

        imageDiv.innerHTML = `
                <div class="abs_item" >
                    <img src="${fullImageUrl}" class="img-fluid mt-3" alt="Generated Image">
                    <div class="all_options">
                        <div class="fn__icon_options medium_size">
                            <div class="dropdown">
                                <button class="fn__icon_button dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                    <img src="/static/assets/svg/download.svg" alt="" class="fn__svg">
                                </button>
                                <ul class="dropdown-menu dropdown-menu-dark">
                                    <li class="dropdown-item" data-format="png" data-url="${fullImageUrl}">PNG</li>
                                    <li class="dropdown-item" data-format="jpg" data-url="${fullImageUrl}">JPG</li>
                                    <li class="dropdown-item" data-format="jpeg" data-url="${fullImageUrl}">JPEG</li>
                                    <li class="dropdown-item" data-format="gif" data-url="${fullImageUrl}">GIF</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>`;

        console.error('Image element present:', !!imageDiv.querySelector('img'));
        console.error('Image src set:', imageDiv.querySelector('img')?.src);

        downloadSection.style.display = 'block';
        imageContainer.style.display = 'block';

        console.error('Download section display style:', downloadSection.style.display);
        console.error('Image container display style:', imageContainer.style.display);

        // 4. Vérifier que l'image est bien visible
        const insertedImg = imageDiv.querySelector('img');
        if (insertedImg) {
            console.error('Image inserted successfully');
            insertedImg.onload = () => console.error('Inserted image loaded')
            insertedImg.onerror = () => console.error('Inserted image failed to load');
        } else {
            console.error('Failed to insert image element');
        }

        document.getElementById('generate-text').textContent = 'Générer une nouvelle image';

        loadHistory(1, false);
    };
    newImage.onerror = function() {
        console.error('Failed to load test image');
        showErrorOverlay('Error', 'impossible to load the image');
    };
    newImage.src = fullImageUrl;
}

// Fonction pour mettre à jour l'affichage des tokens
function updateTokensDisplay(tokensValue = null) {
    console.log("Mise à jour de l'affichage des tokens");

    // Si une valeur est directement fournie, on l'utilise immédiatement
    if (tokensValue !== null && !isNaN(tokensValue)) {
        console.log(`Affichage immédiat de ${tokensValue} tokens`);
        updateTokensUI(tokensValue);
        return;
    }

    // Sinon, on récupère les informations via l'API
    // Récupérer le token de l'URL
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');

    if (!token) {
        console.error("Aucun token trouvé dans l'URL");
        return;
    }
    const tokenSummary = document.querySelector('.token_summary');
    if (tokenSummary) {
        tokenSummary.classList.add('loading-tokens');
    }

    console.log("Récupération des tokens depuis l'API");
    fetch(`/api/user/tokens?token=${encodeURIComponent(token)}`, {
        headers: {
            'X-Requested-With': 'XMLHttpRequest'
        }
    })
    .then(response => {
        if (!response.ok) {
            throw new Error(`Erreur réseau: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        console.log("Token data received:", data);
        if (data.success && data.data) {
            updateTokensUI(data.data.tokens_remaining, data.data);
            const tokenInfoNearCost = document.querySelector('.token-info');
            if (tokenInfoNearCost) {
                const tokenCount = tokenInfoNearCost.querySelector('.count') ||
                                   tokenInfoNearCost.querySelector('.token_summary .count');

                if (tokenCount) {
                    tokenCount.textContent = data.data.tokens_remaining || '--';
                    // Animation pour montrer la mise à jour
                    tokenCount.classList.add('token-change');
                    setTimeout(() => tokenCount.classList.remove('token-change'), 500);
                }

                // Mise à jour du popup d'information sur les tokens
                const tokenPopup = document.querySelector('.token__popup');
                if (tokenPopup && data.data.next_refill) {
                    updateTokenRefreshInfo(tokenPopup, data.data);
                }
            } else {
                console.warn("Élément .token-info non trouvé");
            }
        } else {
            console.error("Erreur lors de la récupération des tokens:", data.error || "Données invalides");
        }
    })
    .catch(error => {
        console.error('Erreur lors de la récupération des tokens:', error);
    })
    .finally(() => {
        if (tokenSummary) {
            tokenSummary.classList.remove('loading-tokens');
        }
    })
}
function updateTokenRefreshInfo(tokenPopup, data) {
    const nextRefill = new Date(data.next_refill);
    const now = new Date();

    // Calcul du temps restant
    let timeText = "--";
    if (!isNaN(nextRefill.getTime())) {
        const diffInHours = Math.max(0, Math.round((nextRefill - now) / (1000 * 60 * 60)));
        const diffInMinutes = Math.max(0, Math.round((nextRefill - now) / (1000 * 60)) % 60);

        if (diffInHours > 0) {
            timeText = `${diffInHours} heure${diffInHours > 1 ? 's' : ''}`;
            if (diffInMinutes > 0) {
                timeText += ` et ${diffInMinutes} minute${diffInMinutes > 1 ? 's' : ''}`;
            }
        } else if (diffInMinutes > 0) {
            timeText = `${diffInMinutes} minute${diffInMinutes > 1 ? 's' : ''}`;
        } else {
            timeText = "moins d'une minute";
        }
    }

    // Mise à jour du contenu avec animation
    const oldContent = tokenPopup.innerHTML;
    const newContent = `
        Resets in <span>${timeText}</span><br>
        Daily limit is <span>${data.token_limit || '--'}</span>
    `;

    // Animation de transition
    tokenPopup.style.opacity = '0.5';
    setTimeout(() => {
        tokenPopup.innerHTML = newContent;
        tokenPopup.style.opacity = '1';
    }, 300);
}
// Fonction auxiliaire pour mettre à jour l'interface utilisateur
function updateTokensUI(tokensRemaining, fullData = null) {
    console.log('Updating tokens UI with value:', tokensRemaining);

    // 1. Mettre à jour le compteur principal
    const tokenCount = document.querySelector('.token_summary .count');
    if (tokenCount) {
        // Sauvegarder l'ancienne valeur pour l'animation
        const oldValue = tokenCount.textContent;
        const numericOldValue = parseInt(oldValue);

        // Définir la nouvelle valeur
        tokenCount.textContent = tokensRemaining;

        // Ajouter une classe d'animation si la valeur a changé
        if (!isNaN(numericOldValue) && numericOldValue !== tokensRemaining) {
            void tokenCount.offsetHeight;
            tokenCount.classList.remove('token-change');

            // Ajout de styles inline pour l'animation en cas d'urgence
            if (numericOldValue > tokensRemaining) {
                // Animation pour diminution (rouge)
                tokenCount.style.color = '#ff6b6b';
                tokenCount.style.fontWeight = 'bold';
                setTimeout(() => {
                    tokenCount.style.transition = 'color 0.5s ease';
                    tokenCount.style.color = '';
                    tokenCount.style.fontWeight = '';
                }, 800);
            }
            // Ajouter la classe d'animation de manière asynchrone
            setTimeout(() => {
                tokenCount.classList.add('token-change');
            }, 10);

            // Retirer la classe après l'animation
            setTimeout(() => tokenCount.classList.remove('token-change'), 800);

            // Mise en évidence supplémentaire pour les tokens bas
            if (tokensRemaining < 30) {
                const upgradeButtons = document.querySelectorAll('a.upgrade, button.upgrade, a.token_upgrade, .token-upgrade-btn');
                upgradeButtons.forEach(button => {
                    button.classList.add('pulse-upgrade');
                    // Ajouter aussi une bordure rouge au conteneur de tokens
                    const tokenContainer = document.querySelector('.token-info');
                    if (tokenContainer) {
                        tokenContainer.style.border = '2px solid #ff6b6b';
                        setTimeout(() => {
                            tokenContainer.style.transition = 'border 0.5s ease';
                            tokenContainer.style.border = '1px solid rgba(142, 120, 255, 0.3)';
                        }, 2000);
                    }
                });
            }
        }
    } else {
        console.warn("Élément .token_summary .count non trouvé");
    }
    improveTokensDisplay();
    updateTokenCost();
}

// Mettre à jour le coût affiché en fonction du modèle sélectionné
function updateTokenCost() {
    const tokenCostElement = document.querySelector('.token-cost');
    if (tokenCostElement) {
        const costs = {
            'dall-e': 20,
            'midjourney': 30
        };
        tokenCostElement.textContent = costs[currentModel] || 20;
    }
}

// Ajouter un écouteur pour les changements de modèle
document.querySelectorAll('.all_models a').forEach(modelLink => {
    modelLink.addEventListener('click', function() {
        // Le code existant reste inchangé

        // Ajouter cette ligne pour mettre à jour le coût affiché
        updateTokenCost();
    });
});

// Nouvelle fonction pour afficher l'erreur de tokens insuffisants avec un design amélioré
function displayTokenError(available, required) {
    // Suppression de tout message d'erreur existant
    const existingError = document.querySelector('.token-upgrade-modal');
    if (existingError) {
        existingError.remove();
    }

    // Calcul du pourcentage pour la barre de progression
    const percentage = Math.min(100, (available / required) * 100);

    // Création du modal
    const modal = document.createElement('div');
    modal.className = 'token-upgrade-modal';
    modal.innerHTML = `
        <div class="token-modal-content">
            <div class="token-modal-header">
                <h3><i class="fas fa-exclamation-circle"></i> Vous avez besoin de plus de tokens</h3>
                <button class="token-modal-close" onclick="this.parentNode.parentNode.parentNode.remove()">×</button>
            </div>
            <div class="token-modal-body">
                <div class="token-info-graphic">
                    <div class="token-meter">
                        <div class="token-meter-fill" style="width: ${percentage}%"></div>
                        <div class="token-meter-marker" style="left: ${percentage}%"></div>
                    </div>
                    <div class="token-labels">
                        <span class="token-available">${available}</span>
                        <span class="token-required">${required}</span>
                    </div>
                </div>

                <p class="token-message">Vous disposez de <strong>${available}</strong> tokens, mais cette opération nécessite <strong>${required}</strong> tokens.</p>

                <div class="token-benefits">
                    <div class="token-benefit-item">
                        <i class="fas fa-bolt"></i>
                        <span>Générez plus d'images</span>
                    </div>
                    <div class="token-benefit-item">
                        <i class="fas fa-chart-line"></i>
                        <span>Augmentez votre limite quotidienne</span>
                    </div>
                    <div class="token-benefit-item">
                        <i class="fas fa-crown"></i>
                        <span>Débloquez des fonctionnalités premium</span>
                    </div>
                </div>
            </div>
            <div class="token-modal-footer">
                <a href="/pricing.html" class="token-upgrade-button">Mettre à niveau mon abonnement</a>
                <button class="token-secondary-button" onclick="this.parentNode.parentNode.parentNode.remove()">Continuer avec la version gratuite</button>
            </div>
        </div>
    `;

    // Injection dans le document
    document.body.appendChild(modal);

    // Animation d'entrée
    setTimeout(() => {
        modal.classList.add('active');
    }, 10);

    // Ajout des styles
    if (!document.getElementById('token-upgrade-styles')) {
        const style = document.createElement('style');
        style.id = 'token-upgrade-styles';
        style.textContent = `
            .token-upgrade-modal {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(0, 0, 0, 0.75);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
                opacity: 0;
                transition: opacity 0.3s ease;
                backdrop-filter: blur(3px);
            }

            .token-upgrade-modal.active {
                opacity: 1;
            }

            .token-modal-content {
                width: 90%;
                max-width: 500px;
                background-color: #1e1e2d;
                border-radius: 10px;
                overflow: hidden;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
                border: 1px solid rgba(255, 255, 255, 0.1);
                transform: translateY(20px);
                transition: transform 0.3s ease;
            }

            .token-upgrade-modal.active .token-modal-content {
                transform: translateY(0);
            }

            .token-modal-header {
                padding: 20px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                background-color: #2d2d42;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }

            .token-modal-header h3 {
                margin: 0;
                color: #fff;
                font-size: 18px;
                font-weight: 600;
                display: flex;
                align-items: center;
                gap: 10px;
            }

            .token-modal-header h3 i {
                color: #ff6b6b;
            }

            .token-modal-close {
                background: none;
                border: none;
                color: rgba(255, 255, 255, 0.6);
                font-size: 24px;
                cursor: pointer;
                padding: 0;
                line-height: 1;
                transition: color 0.2s;
            }

            .token-modal-close:hover {
                color: #fff;
            }

            .token-modal-body {
                padding: 20px;
                color: rgba(255, 255, 255, 0.8);
            }

            .token-info-graphic {
                margin-bottom: 20px;
            }

            .token-meter {
                height: 8px;
                background-color: rgba(255, 255, 255, 0.1);
                border-radius: 4px;
                position: relative;
                margin: 5px 0 8px;
                overflow: hidden;
            }

            .token-meter-fill {
                height: 100%;
                background: linear-gradient(90deg, #ff6b6b, #ff8e72);
                border-radius: 4px;
                transition: width 0.5s ease-out;
            }

            .token-meter-marker {
                position: absolute;
                top: -4px;
                width: 16px;
                height: 16px;
                background-color: #fff;
                border-radius: 50%;
                transform: translateX(-50%);
                box-shadow: 0 0 10px rgba(255, 107, 107, 0.7);
            }

            .token-labels {
                display: flex;
                justify-content: space-between;
                font-size: 14px;
                color: rgba(255, 255, 255, 0.7);
            }

            .token-available {
                font-weight: bold;
                color: #ff6b6b;
            }

            .token-required {
                font-weight: bold;
                color: #fff;
            }

            .token-message {
                margin: 20px 0;
                font-size: 16px;
                line-height: 1.5;
                text-align: center;
            }

            .token-message strong {
                color: #fff;
                font-weight: 600;
            }

            .token-benefits {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 15px;
                margin-top: 20px;
                padding: 15px;
                background-color: rgba(255, 255, 255, 0.05);
                border-radius: 8px;
            }

            .token-benefit-item {
                display: flex;
                flex-direction: column;
                align-items: center;
                text-align: center;
                gap: 10px;
            }

            .token-benefit-item i {
                font-size: 24px;
                color: #8e78ff;
            }

            .token-benefit-item span {
                font-size: 13px;
                line-height: 1.3;
            }

            .token-modal-footer {
                padding: 20px;
                display: flex;
                flex-direction: column;
                gap: 10px;
                background-color: rgba(0, 0, 0, 0.2);
            }

            .token-upgrade-button {
                display: block;
                padding: 12px 24px;
                background: linear-gradient(135deg, #8e78ff, #6c5ce7);
                color: white;
                border: none;
                border-radius: 6px;
                font-size: 16px;
                font-weight: 600;
                text-align: center;
                cursor: pointer;
                transition: transform 0.2s, box-shadow 0.2s;
                text-decoration: none;
                box-shadow: 0 4px 10px rgba(108, 92, 231, 0.4);
            }

            .token-upgrade-button:hover {
                transform: translateY(-2px);
                box-shadow: 0 6px 15px rgba(108, 92, 231, 0.5);
            }

            .token-secondary-button {
                background: none;
                border: none;
                color: rgba(255, 255, 255, 0.7);
                padding: 10px;
                font-size: 14px;
                cursor: pointer;
                transition: color 0.2s;
            }

            .token-secondary-button:hover {
                color: white;
            }

            /* Pour les appareils mobiles */
            @media (max-width: 640px) {
                .token-benefits {
                    grid-template-columns: 1fr;
                }

                .token-modal-content {
                    width: 95%;
                }
            }
        `;
        document.head.appendChild(style);
    }

    // Si Font Awesome n'est pas déjà chargé, utiliser des caractères Unicode basiques
    if (!document.querySelector('link[href*="font-awesome"]')) {
        const icons = modal.querySelectorAll('.token-modal-body i, .token-modal-header i');
        icons.forEach(icon => {
            if (icon.classList.contains('fa-exclamation-circle')) {
                icon.textContent = '⚠️ ';
            } else if (icon.classList.contains('fa-bolt')) {
                icon.textContent = '⚡ ';
            } else if (icon.classList.contains('fa-chart-line')) {
                icon.textContent = '📈 ';
            } else if (icon.classList.contains('fa-crown')) {
                icon.textContent = '👑 ';
            }
            icon.style.marginRight = '5px';
        });
    }

    return modal;
}
// Amélioration de l'affichage des tokens dans l'interface
function improveTokensDisplay() {
    // Récupérer le conteneur des tokens en haut
    const tokenContainers = document.querySelectorAll('.token_summary, .token-info');

    tokenContainers.forEach(container => {
        // Ajouter une classe pour le style
        container.classList.add('improved-token-display');

        // Récupérer le nombre de tokens
        const countElement = container.querySelector('.count');
        if (countElement) {
            const tokenValue = countElement.textContent.trim();
            const isLow = parseInt(tokenValue) < 30; // Considérer comme bas si moins de 30 tokens

            // Ajouter une indication visuelle si les tokens sont bas
            if (isLow && !container.querySelector('.token-indicator')) {
                const indicator = document.createElement('span');
                indicator.className = 'token-indicator token-low';
                indicator.innerHTML = '⚠️ low';
                container.appendChild(indicator);
            }
        }
    });

    // Améliorer le bouton upgrade
    const upgradeButtons = document.querySelectorAll('a.upgrade, button.upgrade, a.token_upgrade, .token-upgrade-btn');
    upgradeButtons.forEach(button => {
        button.classList.add('improved-upgrade-button');
    });

    // Styles pour les améliorations
    if (!document.getElementById('improved-tokens-styles')) {
        const style = document.createElement('style');
        style.id = 'improved-tokens-styles';
        style.textContent = `
            .improved-token-display {
                position: relative;
                background-color: rgba(142, 120, 255, 0.1);
                border: 1px solid rgba(142, 120, 255, 0.3);
                border-radius: 8px;
                padding: 8px 12px;
                transition: all 0.3s ease;
            }

            .improved-token-display:hover {
                background-color: rgba(142, 120, 255, 0.15);
                border-color: rgba(142, 120, 255, 0.5);
            }

            .token-indicator {
                display: inline-block;
                font-size: 12px;
                padding: 3px 6px;
                border-radius: 4px;
                margin-left: 8px;
                animation: pulse 2s infinite;
            }

            .token-low {
                background-color: rgba(255, 107, 107, 0.2);
                color: #ff6b6b;
            }

            @keyframes pulse {
                0% { opacity: 0.7; }
                50% { opacity: 1; }
                100% { opacity: 0.7; }
            }

            .improved-upgrade-button {
                background: linear-gradient(135deg, #8e78ff, #6c5ce7) !important;
                color: white !important;
                border: none !important;
                border-radius: 6px !important;
                padding: 8px 16px !important;
                font-weight: 600 !important;
                box-shadow: 0 4px 10px rgba(108, 92, 231, 0.4) !important;
                transition: transform 0.2s, box-shadow 0.2s !important;
            }

            .improved-upgrade-button:hover {
                transform: translateY(-2px) !important;
                box-shadow: 0 6px 15px rgba(108, 92, 231, 0.5) !important;
            }

            /* Animation de mise en évidence pour les boutons Upgrade */
            .pulse-upgrade {
                animation: pulse-upgrade 2s infinite;
            }

            @keyframes pulse-upgrade {
                0% { transform: scale(1); }
                50% { transform: scale(1.05); }
                100% { transform: scale(1); }
            }
        `;
        document.head.appendChild(style);
    }
}

function loadFontAwesome() {
    if (!document.querySelector('link[href*="font-awesome"]')) {
        const link = document.createElement('link');
        link.rel = 'stylesheet';
        link.href = 'https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css';
        document.head.appendChild(link);
    }
}

// Ajoutez ce script à la fin de votre fichier template ou dans un fichier JS séparé

// Mettre à jour l'aperçu du ratio
function updateRatioPreview() {
    const ratioSelect = document.getElementById('aspect-ratio-select');
    const previewBox = document.getElementById('ratio-preview-box');
    const previewInner = document.getElementById('ratio-preview-inner');

    if (!ratioSelect || !previewBox || !previewInner) return;

    const selectedRatio = ratioSelect.value;

    if (!selectedRatio) {
        // Format par défaut (1:1)
        previewInner.style.width = '80%';
        previewInner.style.height = '80%';
        return;
    }

    const [width, height] = selectedRatio.split(':').map(Number);

    // Calculer la taille de l'aperçu en fonction du ratio
    const boxWidth = previewBox.clientWidth * 0.8;
    const boxHeight = previewBox.clientHeight * 0.8;

    let previewWidth, previewHeight;

    if (width / height > boxWidth / boxHeight) {
        // Limité par la largeur
        previewWidth = boxWidth;
        previewHeight = boxWidth * (height / width);
    } else {
        // Limité par la hauteur
        previewHeight = boxHeight;
        previewWidth = boxHeight * (width / height);
    }

    previewInner.style.width = `${previewWidth}px`;
    previewInner.style.height = `${previewHeight}px`;
}

// Mettre à jour l'affichage du niveau de chaos
function updateChaosValue() {
    const chaosSlider = document.getElementById('chaos-slider');
    const chaosValue = document.getElementById('chaos-value');

    if (chaosSlider && chaosValue) {
        chaosValue.textContent = chaosSlider.value;
    }
}

// Fonction pour collecter tous les paramètres pour Midjourney
function collectMidjourneyParams() {
    return {
        aspect_ratio: document.getElementById('aspect-ratio-select')?.value || null,
        style: document.getElementById('style-select')?.value || null,
        quality: document.getElementById('quality-select')?.value || null,
        chaos: document.getElementById('chaos-slider')?.value || null,
        version: document.getElementById('version-select')?.value || null,
        seed: document.getElementById('seed-input')?.value || null,
        no_text: document.getElementById('no-text')?.checked || false,
        enhance_details: document.getElementById('enhance-details')?.checked || false,
        photorealistic: document.getElementById('photorealistic')?.checked || false,
        medium: document.getElementById('medium-select')?.value || null
    };
}

// Modifier le gestionnaire d'événements du formulaire de génération d'image
document.addEventListener('DOMContentLoaded', function() {
    // Initialiser l'aperçu du ratio
    updateRatioPreview();

    // Initialiser l'affichage du niveau de chaos
    updateChaosValue();

    // Ajouter les gestionnaires d'événements
    const ratioSelect = document.getElementById('aspect-ratio-select');
    if (ratioSelect) {
        ratioSelect.addEventListener('change', updateRatioPreview);
    }

    const chaosSlider = document.getElementById('chaos-slider');
    if (chaosSlider) {
        chaosSlider.addEventListener('input', updateChaosValue);
    }

    // Modifier le gestionnaire d'événements du formulaire
    const generateForm = document.getElementById('generate-image-form');
    if (generateForm) {
        // Sauvegarder l'ancien gestionnaire d'événements si nécessaire
        const originalSubmitHandler = generateForm.onsubmit;

        generateForm.onsubmit = async function(event) {
            event.preventDefault();

            const promptInput = document.getElementById('prompt');
            const promptText = promptInput.value;
            const spinner = document.getElementById('spinner');
            const generateText = document.getElementById('generate-text');

            // Récupérer le modèle sélectionné
            const modelOption = document.querySelector('.all_models a.selected');
            const modelName = modelOption ? modelOption.textContent.toLowerCase() : currentModel;

            // Si c'est Midjourney, collecter les paramètres supplémentaires
            let additionalParams = {};
            if (modelName.includes('midjourney')) {
                additionalParams = collectMidjourneyParams();
                console.log('Midjourney params:', additionalParams);
            }

            // Afficher l'état de chargement
            promptInput.disabled = true;
            spinner.style.display = 'inline-block';
            generateText.style.display = 'none';

            // Obtenir le token
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');

            if (!token) {
                showErrorOverlay('Erreur', 'Session invalide. Veuillez vous reconnecter.');
                setTimeout(() => {
                    window.location.href = LOGIN_URL;
                }, 2000);
                return;
            }

            try {
                updateLoadingState('loading');

                // Construire la requête
                const requestData = new URLSearchParams();
                requestData.append('prompt', promptText);
                requestData.append('model', modelName);

                // Ajouter les paramètres additionnels pour Midjourney
                if (Object.keys(additionalParams).length > 0) {
                    requestData.append('additional_params', JSON.stringify(additionalParams));
                }

                const requestOptions = {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'X-Requested-With': 'XMLHttpRequest'
                    },
                    body: requestData
                };

                console.log('Sending request with options:', requestOptions);

                // Envoyer la requête au backend
                const response = await fetch(`/generate_image?token=${encodeURIComponent(token)}`, requestOptions);

                // Traitement de la réponse
                console.log('Response status:', response.status);

                const result = await response.json();
                console.log('Response data:', result);

                // Gestion des tokens insuffisants
                if (result.error === "Insufficient tokens") {
                    const modal = displayTokenError(result.tokens_available, result.tokens_required);
                    updateLoadingState('default');
                    return;
                }

                // Gestion des autres erreurs
                if (!result.success) {
                    console.error('Error in response:', result.error || 'Unknown error');
                    showErrorOverlay('Erreur', result.message || result.error || 'Une erreur est survenue');
                    updateLoadingState('default');
                    return;
                }

                // Traitement des succès
                console.log('Success response:', result);

                // Cas spécial pour Midjourney (traitement asynchrone)
                if (modelName === 'midjourney' && result.status === 'processing') {
                    console.log('Starting Midjourney processing with task_id:', result.task_id);
                    updateLoadingState('processing');
                    displayInitialLoadingState();
                    handleMidjourneyProcessing(result.task_id, token, promptText);
                } else {
                    // Cas DALL-E ou autre réponse immédiate
                    console.log('Displaying generated image:', result.image_url);
                    displayGeneratedImage(result.image_url);

                    // Mise à jour explicite des tokens si disponible
                    if (result.tokens_remaining !== undefined) {
                        console.log('Updating tokens display to:', result.tokens_remaining);
                        updateTokensUI(result.tokens_remaining);
                    } else {
                        // Sinon, rafraîchir les tokens via l'API
                        updateTokensDisplay();
                    }

                    // Mettre à jour le texte du bouton
                    generateText.textContent = 'Générer une nouvelle image';
                }
            } catch (error) {
                console.error('Error in fetch operation:', error);
                showErrorOverlay('Erreur', 'Impossible de contacter le serveur. Veuillez réessayer plus tard.');
            } finally {
                // Réinitialisation de l'interface
                spinner.style.display = 'none';
                generateText.style.display = 'inline';
                promptInput.disabled = false;
            }
        };
    }
});

// Fonction pour réinitialiser les paramètres Midjourney
function resetMidjourneyParams() {
    // Réinitialiser tous les sélecteurs et options
    document.getElementById('aspect-ratio-select').value = '';
    document.getElementById('style-select').value = '';
    document.getElementById('medium-select').value = '';
    document.getElementById('quality-select').value = '2';
    document.getElementById('version-select').value = '6.0';
    document.getElementById('seed-input').value = '';
    document.getElementById('chaos-slider').value = '0';
    document.getElementById('chaos-value').textContent = '0';
    document.getElementById('enhance-details').checked = false;
    document.getElementById('photorealistic').checked = false;
    document.getElementById('no-text').checked = false;

    // Mettre à jour l'aperçu du ratio
    updateRatioPreview();
}

// Ajouter un gestionnaire pour le bouton "Nouvelle image"
document.addEventListener('DOMContentLoaded', function() {
    const newImageBtn = document.querySelector('.fn__icon_button[onclick="createNewInstance()"]');
    if (newImageBtn) {
        const originalOnclick = newImageBtn.onclick;
        newImageBtn.onclick = function() {
            if (originalOnclick) originalOnclick.call(this);
            resetMidjourneyParams();
        };
    }

    // Initialiser les fonctionnalités des modèles
    initializeTemplateSystem();

    // Ajouter des tooltips interactifs pour mieux expliquer les options
    initializeTooltips();
});

// Système de modèles (templates)
function initializeTemplateSystem() {
    const templateSelect = document.getElementById('template-select');
    if (!templateSelect) return;

    // Gérer le changement de modèle
    templateSelect.addEventListener('change', function() {
        const selectedTemplate = this.value;

        // Cacher tous les paramètres spécifiques
        document.querySelectorAll('.template-specific-params').forEach(el => {
            el.classList.add('d-none');
        });

        // Afficher les paramètres spécifiques au modèle sélectionné
        if (selectedTemplate) {
            document.getElementById('template-params').classList.remove('d-none');
            const specificParams = document.getElementById(`params-${selectedTemplate}`);
            if (specificParams) {
                specificParams.classList.remove('d-none');
            }
        } else {
            document.getElementById('template-params').classList.add('d-none');
        }
    });

    // Ajouter un bouton pour appliquer le modèle
    const applyTemplateBtn = document.getElementById('apply-template-btn');
    if (applyTemplateBtn) {
        applyTemplateBtn.addEventListener('click', function() {
            applySelectedTemplate();
        });
    }
}

// Appliquer le modèle sélectionné au prompt
function applySelectedTemplate() {
    const templateType = document.getElementById('template-select').value;
    if (!templateType) return;

    const subject = document.getElementById('template-subject').value;
    if (!subject) {
        showTemplateError('Veuillez entrer un sujet principal');
        return;
    }

    // Collecter les paramètres spécifiques au modèle
    const params = {
        subject: subject
    };

    // Récupérer les paramètres spécifiques en fonction du modèle
    if (templateType === 'portrait') {
        params.style = document.getElementById('portrait-style').value;
        params.lighting = document.getElementById('portrait-lighting').value;
        params.background = document.getElementById('portrait-background').value;
    } else if (templateType === 'landscape') {
        params.time_of_day = document.getElementById('landscape-time').value;
        params.weather = document.getElementById('landscape-weather').value;
        params.style = document.getElementById('landscape-style').value;
    } else if (templateType === 'product') {
        params.background = document.getElementById('product-background').value;
        params.angle = document.getElementById('product-angle').value;
    } else if (templateType === 'concept_art') {
        params.style = document.getElementById('concept-style').value;
        params.artist = document.getElementById('concept-artist').value;
    } else if (templateType === 'food') {
        params.lighting = document.getElementById('food-lighting').value;
        params.angle = document.getElementById('food-angle').value;
        params.style = document.getElementById('food-style').value;
    }

    // Appeler l'API pour générer le prompt
    fetch(`/api/midjourney/templates/${templateType}?subject=${encodeURIComponent(subject)}&token=${encodeURIComponent(getToken())}${formatParamsForUrl(params)}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                // Mettre à jour le champ de prompt
                document.getElementById('prompt').value = data.prompt;

                // Afficher un message de succès
                showSuccessNotification('Modèle appliqué avec succès!');
            } else {
                showTemplateError(data.error || 'Erreur lors de l\'application du modèle');
            }
        })
        .catch(error => {
            console.error('Error applying template:', error);
            showTemplateError('Erreur de connexion');
        });
}

// Formater les paramètres pour l'URL
function formatParamsForUrl(params) {
    let result = '';
    for (const key in params) {
        if (key !== 'subject' && params[key]) {
            result += `&${key}=${encodeURIComponent(params[key])}`;
        }
    }
    return result;
}

// Afficher une erreur de modèle
function showTemplateError(message) {
    const errorBox = document.createElement('div');
    errorBox.className = 'template-error animated fadeIn';
    errorBox.innerHTML = `
        <div class="error-icon"><i class="fas fa-exclamation-circle"></i></div>
        <div class="error-message">${message}</div>
        <div class="error-close" onclick="this.parentNode.remove()">×</div>
    `;

    document.getElementById('template-params').appendChild(errorBox);

    // Supprimer l'erreur après 5 secondes
    setTimeout(() => {
        errorBox.classList.add('fadeOut');
        setTimeout(() => errorBox.remove(), 500);
    }, 5000);
}

// Afficher une notification de succès
function showSuccessNotification(message) {
    const notification = document.createElement('div');
    notification.className = 'success-notification animated fadeIn';
    notification.innerHTML = `
        <div class="success-icon"><i class="fas fa-check-circle"></i></div>
        <div class="success-message">${message}</div>
    `;

    document.body.appendChild(notification);

    // Supprimer la notification après 3 secondes
    setTimeout(() => {
        notification.classList.add('fadeOut');
        setTimeout(() => notification.remove(), 500);
    }, 3000);
}

// Initialiser les tooltips
function initializeTooltips() {
    // Ajouter des tooltips sur chaque option
    const tooltipElements = document.querySelectorAll('[data-tooltip]');
    tooltipElements.forEach(element => {
        element.addEventListener('mouseenter', function() {
            const tooltipText = this.getAttribute('data-tooltip');

            // Créer le tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'custom-tooltip';
            tooltip.textContent = tooltipText;

            // Positionner le tooltip
            const rect = this.getBoundingClientRect();
            tooltip.style.left = `${rect.left + (rect.width / 2)}px`;
            tooltip.style.top = `${rect.top - 5}px`;

            // Ajouter au body
            document.body.appendChild(tooltip);

            // Animation d'entrée
            setTimeout(() => tooltip.classList.add('visible'), 10);

            // Stocker une référence au tooltip
            this._tooltip = tooltip;
        });

        element.addEventListener('mouseleave', function() {
            if (this._tooltip) {
                this._tooltip.classList.remove('visible');
                setTimeout(() => this._tooltip.remove(), 200);
                this._tooltip = null;
            }
        });
    });
}

// Obtenir le token de l'URL
function getToken() {
    const urlParams = new URLSearchParams(window.location.search);
    return urlParams.get('token') || '';
}

// Gestion des collections
function initializeCollections() {
    // Charger les collections de l'utilisateur
    loadUserCollections();

    // Ajouter un gestionnaire pour le bouton de création de collection
    const createCollectionBtn = document.getElementById('create-collection-btn');
    if (createCollectionBtn) {
        createCollectionBtn.addEventListener('click', function() {
            showCreateCollectionModal();
        });
    }
}

// Charger les collections de l'utilisateur
function loadUserCollections() {
    fetch(`/api/midjourney/collections?token=${encodeURIComponent(getToken())}`)
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                renderCollections(data.collections);
            } else {
                console.error('Error loading collections:', data.error);
            }
        })
        .catch(error => {
            console.error('Error loading collections:', error);
        });
}

// Afficher les collections
function renderCollections(collections) {
    const collectionsContainer = document.getElementById('collections-container');
    if (!collectionsContainer) return;

    if (collections.length === 0) {
        collectionsContainer.innerHTML = '<div class="empty-collections">Aucune collection. Créez-en une pour organiser vos images.</div>';
        return;
    }

    let html = '';
    collections.forEach(collection => {
        html += `
            <div class="collection-item" data-id="${collection.id}">
                <div class="collection-header">
                    <h4>${collection.name}</h4>
                    <div class="collection-count">${collection.images.length} images</div>
                </div>
                <div class="collection-description">${collection.description || 'Aucune description'}</div>
                <div class="collection-actions">
                    <button class="btn btn-sm btn-outline-primary view-collection-btn">Voir</button>
                    <button class="btn btn-sm btn-outline-danger delete-collection-btn">Supprimer</button>
                </div>
            </div>
        `;
    });

    collectionsContainer.innerHTML = html;

    // Ajouter les gestionnaires d'événements
    collectionsContainer.querySelectorAll('.view-collection-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const collectionId = this.closest('.collection-item').dataset.id;
            viewCollection(collectionId);
        });
    });

    collectionsContainer.querySelectorAll('.delete-collection-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            const collectionId = this.closest('.collection-item').dataset.id;
            deleteCollection(collectionId);
        });
    });
}

// Afficher le modal de création de collection
function showCreateCollectionModal() {
    const modal = document.createElement('div');
    modal.className = 'custom-modal';
    modal.innerHTML = `
        <div class="modal-content">
            <div class="modal-header">
                <h4>Créer une collection</h4>
                <span class="close-modal">&times;</span>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="collection-name">Nom de la collection</label>
                    <input type="text" id="collection-name" class="form-control" placeholder="Ma collection">
                </div>
                <div class="form-group">
                    <label for="collection-description">Description (optionnelle)</label>
                    <textarea id="collection-description" class="form-control" rows="3" placeholder="Description de la collection"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button id="create-collection-submit" class="btn btn-primary">Créer</button>
                <button class="btn btn-secondary close-modal-btn">Annuler</button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    // Animation d'entrée
    setTimeout(() => modal.classList.add('visible'), 10);

    // Gestionnaires d'événements
    modal.querySelector('.close-modal').addEventListener('click', () => closeModal(modal));
    modal.querySelector('.close-modal-btn').addEventListener('click', () => closeModal(modal));

    modal.querySelector('#create-collection-submit').addEventListener('click', function() {
        const name = document.getElementById('collection-name').value;
        const description = document.getElementById('collection-description').value;

        if (!name) {
            showModalError(modal, 'Veuillez entrer un nom de collection');
            return;
        }

        createCollection(name, description, modal);
    });
}

// Fermer un modal
function closeModal(modal) {
    modal.classList.remove('visible');
    setTimeout(() => modal.remove(), 300);
}

// Afficher une erreur dans le modal
function showModalError(modal, message) {
    let errorElement = modal.querySelector('.modal-error');

    if (!errorElement) {
        errorElement = document.createElement('div');
        errorElement.className = 'modal-error';
        modal.querySelector('.modal-body').prepend(errorElement);
    }

    errorElement.textContent = message;
    errorElement.style.display = 'block';
}

// Créer une collection
function createCollection(name, description, modal) {
    fetch('/api/midjourney/collections', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'X-Requested-With': 'XMLHttpRequest'
        },
        body: JSON.stringify({
            name,
            description,
            token: getToken()
        })
    })
    .then(response => response.json())
    .then(data => {
        if (data.success) {
            closeModal(modal);
            showSuccessNotification('Collection créée avec succès!');
            loadUserCollections();
        } else {
            showModalError(modal, data.error || 'Erreur lors de la création de la collection');
        }
    })
    .catch(error => {
        console.error('Error creating collection:', error);
        showModalError(modal, 'Erreur de connexion');
    });
}

function optimizeUpgradeButtons() {
    // Trouver les boutons upgrade existants
    const upgradeButtons = document.querySelectorAll('a.upgrade, button.upgrade, a.token_upgrade, .token-upgrade-btn');

    // S'il y a plusieurs boutons, n'en garder que le plus pertinent
    if (upgradeButtons.length > 1) {
        // Conserver le bouton principal et masquer les autres
        const mainButton = upgradeButtons[0];
        mainButton.classList.add('primary-upgrade-button');

        // Masquer les boutons secondaires ou les rendre moins visibles
        for (let i = 1; i < upgradeButtons.length; i++) {
            // Option 1: Masquer complètement
            // upgradeButtons[i].style.display = 'none';

            // Option 2: Rendre moins visible mais toujours accessible
            upgradeButtons[i].classList.add('secondary-upgrade-button');
            upgradeButtons[i].style.opacity = '0.7';
            upgradeButtons[i].style.transform = 'scale(0.9)';
        }
    }

    // Améliorer l'apparence des boutons upgrade conservés
    upgradeButtons.forEach(button => {
        // Vérifier si le bouton a déjà le style amélioré
        if (!button.classList.contains('improved-upgrade-button')) {
            button.classList.add('improved-upgrade-button');

            // Ajouter une icône si elle n'existe pas déjà
            if (!button.querySelector('i')) {
                const buttonText = button.textContent.trim();
                button.innerHTML = `<i class="fas fa-crown"></i> ${buttonText}`;
            }
        }
    });
}

// 4. Fonction pour améliorer l'affichage global des tokens et limites

function enhanceTokensInfoDisplay() {
    // Trouver les éléments qui affichent les informations sur les tokens
    const tokenInfoElements = document.querySelectorAll('.token__popup, .token-info');

    tokenInfoElements.forEach(element => {
        // Obtenir le texte actuel
        const currentContent = element.innerHTML;

        // Si le contenu contient déjà notre format amélioré, ne rien faire
        if (currentContent.includes('token-refresh-info')) return;

        // Extraire les informations principales (resets et limits)
        const resetInfo = element.textContent.match(/Resets in ([^<]+)/);
        const limitInfo = element.textContent.match(/Daily limit is ([^<]+)/);

        // Créer une version améliorée
        const resetText = resetInfo ? resetInfo[1].trim() : '--';
        const limitText = limitInfo ? limitInfo[1].trim() : '--';

        // Restructurer l'élément avec un format plus attrayant
        element.innerHTML = `
            <div class="token-info-enhanced">
                <div class="token-refresh-section">
                    <div class="token-refresh-info">
                        <i class="fas fa-sync-alt"></i> Réinitialisation dans <span>${resetText}</span>
                    </div>
                    <div class="token-limit-info">
                        <i class="fas fa-chart-pie"></i> Limite quotidienne: <span>${limitText}</span>
                    </div>
                </div>
            </div>
        `;
    });

    // Ajouter les styles pour ces éléments améliorés
    if (!document.getElementById('token-info-enhanced-styles')) {
        const style = document.createElement('style');
        style.id = 'token-info-enhanced-styles';
        style.textContent = `
            .token-info-enhanced {
                padding: 8px 12px;
                background: rgba(142, 120, 255, 0.1);
                border-radius: 8px;
                margin-top: 8px;
            }

            .token-refresh-section {
                display: flex;
                flex-direction: column;
                gap: 6px;
            }

            .token-refresh-info, .token-limit-info {
                display: flex;
                align-items: center;
                gap: 8px;
                color: rgba(255, 255, 255, 0.8);
                font-size: 13px;
            }

            .token-refresh-info i, .token-limit-info i {
                color: #8e78ff;
                font-size: 14px;
            }

            .token-refresh-info span, .token-limit-info span {
                color: white;
                font-weight: 600;
            }
        `;
        document.head.appendChild(style);
    }
}


function calculatePollingDelay(prompt) {
    if (!prompt || typeof prompt !== 'string') {
        console.error('Invalid prompt passed to calculatePollingDelay:', prompt);
        return 5000; // Return default delay if prompt is invalid
    }
    let baseDelay = 7000;
    const maxAdditionalDelay = 15000;
    let complexityScore = 0;

    const wordCount = prompt.split(/\s+/).length;
    if (wordCount > 50) complexityScore += 3;
    else if (wordCount > 30) complexityScore += 2;
    else if (wordCount > 15) complexityScore += 1;

    const complexityIndicators = [
        // Detailed styles and effects
        'realistic', 'photorealistic', 'hyper-realistic', 'detailed', 'intricate',
        'high resolution', 'high detail', '8k', '4k', 'ray tracing', 'volumetric lighting',

        // Complex scene descriptors
        'landscape', 'cityscape', 'panorama', 'scene', 'environment',

        // Multiple subjects
        'group', 'crowd', 'multiple', 'many',

        // Difficult rendering elements
        'reflection', 'glass', 'water', 'mirror', 'transparent', 'translucent',
        'chromatic aberration', 'bokeh', 'depth of field',

        // Specific artistic styles that take longer
        'oil painting', 'watercolor', 'concept art', 'matte painting',

        // Specific lighting conditions
        'sunset', 'sunrise', 'night scene', 'dramatic lighting', 'cinematic',

        // Atmosphere effects
        'fog', 'mist', 'rain', 'snow', 'particles',

        //complex rendering process
        'low angle', 'fisheye', 'first person view', 'a first-person view', 'POV'
    ]

    let indicatorCount = 0;
    complexityIndicators.forEach(indicator =>{
        if (prompt.toLowerCase().includes(indicator.toLowerCase())) {
            indicator++;
        }
    });

    // Add to complexity score based on number of indicators
    if (indicatorCount > 10) complexityScore += 5;
    else if (indicatorCount > 7) complexityScore += 4;
    else if (indicatorCount > 5) complexityScore += 3;
    else if (indicatorCount > 3) complexityScore += 2;
    else if (indicatorCount > 1) complexityScore += 1;

    complexityScore = Math.min(complexityScore, 7); //Max score of 7

    const additionalDelay = Math.min(complexityScore * 2000, maxAdditionalDelay);
    const totalDelay = baseDelay + additionalDelay

    console.log(`Prompt complexity score: ${complexityScore}, Total delay: ${totalDelay}ms`);
    return totalDelay
}

function updateLoadingState(state) {
    const generateText = document.getElementById('generate-text');
    const spinner = document.getElementById('spinner');

    switch(state) {
        case 'loading':
            spinner.style.display = 'inline-block';
            generateText.style.display = 'none';
            break;
        case 'processing':
            spinner.style.display = 'inline-block';
            generateText.textContent = 'Génération en cours...';
            generateText.style.display = 'inline';
            break;
        case 'complete':
            spinner.style.display = 'none';
            generateText.textContent = 'Générer une nouvelle image';
            generateText.style.display = 'inline';
            break;
        default:
            spinner.style.display = 'none';
            generateText.style.display = 'inline';
    }
}
// Nouvelle fonction pour afficher l'état initial
function displayInitialLoadingState() {
    const imageDiv = document.getElementById('generated-image');
    imageDiv.innerHTML = `
        <div class="generation-status">
            <div class="status-message">Génération en cours...</div>
            <div class="progress-container mt-4">
                <div class="progress-bar" style="width: 0%"></div>
            </div>
        </div>
    `;
}

function updateUpscaleProgress(images) {
    if (!Array.isArray(images)) {
        console.error('Expected images array for updateUpscaleProgress, got', images);
        return;
    }
    const progressSection = document.getElementById('upscale-progress') || createUpscaleProgressSection();
    if (!progressSection) {
        console.error('Failed to create or find upscale progress section');
        return;
    }

    images.forEach((image, index) => {
        const imgObj = typeof image === 'string' ? JSON.parse(image) : image;
        console.error(`Processing image ${index}:`, imgObj);

        // Get the variation/upscale number
        const variationNumber = getVariationNumber(image, index)
        const slot = document.querySelector(`#upscale-slot-${variationNumber}`);

        if (slot && image && image.url) {
            // Get the token to append to the URL if needed
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            const fullImageUrl = normalizeImageUrl(image.url, token);

            slot.innerHTML = `
                <img src="${fullImageUrl}" alt="Variation ${variationNumber + 1}"class="w-full h-full object-cover rounded"onerror="this.onerror=null; this.src='/static/assets/img/placeholder.png'; console.error('Failed to load image');">
                <div class="absolute bottom-0 left-0 bg-green-500 text-white px-2 py-1 text-sm rounded-tr">
                    Complété
                </div>
            `;
        }
    });
}

// Nouvelle fonction pour l'affichage de la grille initiale
function displayInitialGrid(imageUrl) {
    const imageDiv = document.getElementById('generated-image');
    const container = document.createElement('div');
    container.className = 'initial-grid mb-4';
    container.innerHTML = `
        <h4 class="text-center mb-2">Génération initiale</h4>
        <div class="relative">
            <img src="${imageUrl}" alt="Initial grid" class="w-full rounded">
            <div class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 text-white">
                <span>Génération des variations en cours...</span>
            </div>
        </div>
    `;
    imageDiv.innerHTML = '';
    imageDiv.appendChild(container);
}
// Function to create the upscale progress section if it doesn't exist
function createUpscaleProgressSection() {
    const imageDiv = document.getElementById('generated-image');
    if (!imageDiv) {
        console.error('Cannot find generated-image element');
        return null;
    }
    // Remove existing section if present to avoid duplicates
    const existingSection = document.getElementById('upscale-progress');
    if (existingSection) {
        existingSection.remove();
    }

    const progressSection = document.createElement('div');
    progressSection.id = 'upscale-progress';
    progressSection.className = 'grid grid-cols-2 gap-4 mt-4';

    // Create 4 slots for the 4 upscales
    for (let i = 0; i < 4; i++) {
        const slot = document.createElement('div');
        slot.id = `upscale-slot-${i}`;
        slot.className = 'upscale-slot flex items-center justify-center bg-gray-100';
        slot.innerHTML = `
            <div class="text-gray-400">
                <div class="spinner-border spinner-border-sm" role="status"></div>
                <div class="mt-2">En attente...</div>
            </div>
        `;
        progressSection.appendChild(slot);
    }

    imageDiv.appendChild(progressSection);
    return progressSection;
}

// 1. First, let's create a utility function for consistent URL handling
function normalizeImageUrl(imageUrl, token) {
    if (!imageUrl) return '';

    // If already a full URL
    if (imageUrl.startsWith('http')) {
        // Add token if needed
        if (token && !imageUrl.includes('token=')) {
            return `${imageUrl}${imageUrl.includes('?') ? '&' : '?'}token=${encodeURIComponent(token)}`;
        }
        return imageUrl;
    }

    // If it's a relative URL starting with /
    if (imageUrl.startsWith('/')) {
        const baseUrl = `${window.location.origin}${imageUrl}`;
        return token ? `${baseUrl}${baseUrl.includes('?') ? '&' : '?'}token=${encodeURIComponent(token)}` : baseUrl;
    }

    // Default case
    return token ? `${imageUrl}?token=${encodeURIComponent(token)}` : imageUrl;
}
// 2. Helper function for consistent variation number handling
function getVariationNumber(image, fallbackIndex) {
    if (typeof image.variation_number === 'number') return image.variation_number;
    if (typeof image.choice === 'number') return image.choice;
    return fallbackIndex || 0;
}
function checkTwentyTwentyInterference() {
    // Check if TwentyTwenty CSS is loaded
    const twentyTwentyCSS = document.querySelector('link[href*="twentytwenty.css"]');
    console.error('TwentyTwenty CSS loaded:', !!twentyTwentyCSS);

    // Temporarily disable it as a test
    if (twentyTwentyCSS) {
        console.error('Temporarily disabling TwentyTwenty CSS to test');
        twentyTwentyCSS.disabled = true;
    }
}


/**
 * Fixed Midjourney Display Function
 * Simplified version that ensures images display correctly
 */
function displayMidjourneyGroup(groupData) {
    console.error('Starting enhanced displayMidjourneyGroup...');

    // Make sure we have valid data
    if (!groupData || !Array.isArray(groupData.images) || groupData.images.length === 0) {
        console.error('Invalid or empty group data');
        return;
    }

    // Get and reset the main container
    const imageDiv = document.getElementById('generated-image');
    if (!imageDiv) {
        console.error('Cannot find generated-image container');
        alert('Error: Image container not found!');
        return;
    }

    // Force any containing elements to be visible
    let parent = imageDiv;
    for (let i = 0; i < 5; i++) { // Check up to 5 parent levels
        if (!parent) break;

        parent.style.display = 'block';
        parent.style.visibility = 'visible';
        parent.style.opacity = '1';
        parent.style.height = 'auto';
        parent.style.overflow = 'visible';

        parent = parent.parentElement;
    }

    // Reset the container with explicit styles
    imageDiv.innerHTML = '';
    imageDiv.style.display = 'block';
    imageDiv.style.visibility = 'visible';
    imageDiv.style.opacity = '1';
    imageDiv.style.width = '100%';
    imageDiv.style.minHeight = '400px';
    imageDiv.style.backgroundColor = '#ffffff';
    imageDiv.style.padding = '15px';
    imageDiv.style.boxSizing = 'border-box';
    imageDiv.style.border = '1px solid #e0e0e0';
    imageDiv.style.borderRadius = '8px';
    imageDiv.style.margin = '20px 0';
    imageDiv.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';

    // Create main container
    const container = document.createElement('div');
    container.style.width = '100%';
    container.style.padding = '10px';
    container.style.boxSizing = 'border-box';

    // Add prompt section
    const promptDiv = document.createElement('div');
    promptDiv.style.marginBottom = '15px';
    promptDiv.style.padding = '10px';
    promptDiv.style.backgroundColor = '#f5f5f5';
    promptDiv.style.borderRadius = '4px';

    const promptText = document.createElement('h3');
    promptText.textContent = groupData.prompt || 'No prompt available';
    promptText.style.margin = '0 0 5px 0';
    promptText.style.fontSize = '16px';
    promptText.style.fontWeight = 'bold';

    const timestampText = document.createElement('p');
    timestampText.textContent = new Date(groupData.timestamp || Date.now()).toLocaleString();
    timestampText.style.margin = '0';
    timestampText.style.fontSize = '12px';
    timestampText.style.color = '#666';

    promptDiv.appendChild(promptText);
    promptDiv.appendChild(timestampText);
    container.appendChild(promptDiv);

    // Create grid with pure inline styles
    const grid = document.createElement('div');
    grid.style.display = 'grid';
    grid.style.gridTemplateColumns = 'repeat(2, 1fr)';
    grid.style.gap = '15px';
    grid.style.padding = '0';
    grid.style.width = '100%';
    grid.style.boxSizing = 'border-box';

    // Get token for URLs
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');

    console.error(`Processing ${groupData.images.length} images`);

    // Create image elements with maximum visibility
    groupData.images.forEach((imageData, index) => {
        let image = imageData;

        // Parse image if it's a string
        if (typeof imageData === 'string') {
            try {
                image = JSON.parse(imageData);
            } catch (e) {
                console.error(`Failed to parse image ${index}:`, e);
                return;
            }
        }

        // Skip invalid images
        if (!image || !image.url) {
            console.error('Missing URL for image:', image);
            return;
        }

        // Get variation number
        const variationNum =
            typeof image.variation_number === 'number' ? image.variation_number :
            typeof image.choice === 'number' ? image.choice :
            index;

        // Ensure URL has token
        const imageUrl = image.url.includes('token=') ? image.url :
            `${image.url}${image.url.includes('?') ? '&' : '?'}token=${encodeURIComponent(token)}`;

        console.error(`Creating image ${index} with URL:`, imageUrl);

        // Create container with explicit styles for maximum visibility
        const imageContainer = document.createElement('div');
        imageContainer.style.position = 'relative';
        imageContainer.style.backgroundColor = '#f0f0f0';
        imageContainer.style.border = '1px solid #ddd';
        imageContainer.style.borderRadius = '8px';
        imageContainer.style.overflow = 'hidden';
        imageContainer.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
        imageContainer.style.transition = 'transform 0.2s';
        imageContainer.style.cursor = 'pointer';

        // Create image element with explicit styles
        const imgElement = document.createElement('img');
        imgElement.src = imageUrl;
        imgElement.alt = `Variation ${variationNum + 1}`;
        imgElement.style.width = '100%';
        imgElement.style.height = 'auto';
        imgElement.style.display = 'block';
        imgElement.style.minHeight = '150px';
        imgElement.style.backgroundColor = '#eee';

        // Add load and error handlers with visual feedback
        imgElement.onload = () => {
            console.error(`Image ${index} loaded successfully`);
            imageContainer.style.backgroundColor = '#fff';
            // Add a subtle border to show it's loaded
            imageContainer.style.border = '1px solid #ccc';
        };

        imgElement.onerror = () => {
            console.error(`Image ${index} failed to load`);
            imgElement.src = '/static/assets/img/placeholder.png';
            imageContainer.style.backgroundColor = '#ffeeee';
            imageContainer.style.border = '1px solid #ffcccc';
        };

        // Add variation number label
        const variationLabel = document.createElement('div');
        variationLabel.textContent = `V${variationNum + 1}`;
        variationLabel.style.position = 'absolute';
        variationLabel.style.bottom = '8px';
        variationLabel.style.left = '8px';
        variationLabel.style.backgroundColor = 'rgba(0,0,0,0.7)';
        variationLabel.style.color = 'white';
        variationLabel.style.padding = '4px 8px';
        variationLabel.style.borderRadius = '4px';
        variationLabel.style.fontSize = '12px';

        // Add download button (optional)
        const downloadBtn = document.createElement('button');
        downloadBtn.textContent = 'Download';
        downloadBtn.style.position = 'absolute';
        downloadBtn.style.top = '8px';
        downloadBtn.style.right = '8px';
        downloadBtn.style.backgroundColor = 'rgba(0,0,0,0.7)';
        downloadBtn.style.color = 'white';
        downloadBtn.style.border = 'none';
        downloadBtn.style.padding = '4px 8px';
        downloadBtn.style.borderRadius = '4px';
        downloadBtn.style.fontSize = '12px';
        downloadBtn.style.cursor = 'pointer';
        downloadBtn.style.opacity = '0';
        downloadBtn.style.transition = 'opacity 0.2s';

        // Show download button on hover
        imageContainer.addEventListener('mouseenter', () => {
            downloadBtn.style.opacity = '1';
        });

        imageContainer.addEventListener('mouseleave', () => {
            downloadBtn.style.opacity = '0';
        });

        // Add download functionality
        downloadBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent opening the large view
            if (typeof downloadImage === 'function') {
                downloadImage(imageUrl, 'png');
            } else {
                window.open(imageUrl, '_blank');
            }
        });

        // Add click for large image view
        imageContainer.addEventListener('click', () => {
            // Create a modal for viewing the full image
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0,0,0,0.9)';
            modal.style.display = 'flex';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            modal.style.zIndex = '9999';

            const modalImg = document.createElement('img');
            modalImg.src = imageUrl;
            modalImg.style.maxWidth = '90%';
            modalImg.style.maxHeight = '90%';
            modalImg.style.objectFit = 'contain';
            modalImg.style.border = '2px solid white';

            const closeBtn = document.createElement('button');
            closeBtn.textContent = '×';
            closeBtn.style.position = 'absolute';
            closeBtn.style.top = '20px';
            closeBtn.style.right = '20px';
            closeBtn.style.backgroundColor = 'transparent';
            closeBtn.style.color = 'white';
            closeBtn.style.border = 'none';
            closeBtn.style.fontSize = '30px';
            closeBtn.style.cursor = 'pointer';

            closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
            });

            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });

            modal.appendChild(modalImg);
            modal.appendChild(closeBtn);
            document.body.appendChild(modal);
        });

        // Assemble components
        imageContainer.appendChild(imgElement);
        imageContainer.appendChild(variationLabel);
        imageContainer.appendChild(downloadBtn);
        grid.appendChild(imageContainer);
    });

    // Add grid to container
    container.appendChild(grid);

    // Add container to page
    imageDiv.appendChild(container);

    // Show download section if it exists
    const downloadSection = document.getElementById('download-section');
    if (downloadSection) {
        downloadSection.style.display = 'block';
    }

    // Update text
    const generateText = document.getElementById('generate-text');
    if (generateText) {
        generateText.textContent = 'Générer une nouvelle image';
    }

    // Add status message at the bottom
    const statusDiv = document.createElement('div');
    statusDiv.style.marginTop = '15px';
    statusDiv.style.padding = '10px';
    statusDiv.style.backgroundColor = '#e6f7e6';
    statusDiv.style.borderRadius = '4px';
    statusDiv.style.textAlign = 'center';
    statusDiv.textContent = 'Images générées avec succès!';
    container.appendChild(statusDiv);

    console.error('Display complete, checking final state...');

    // Final visibility check
    setTimeout(() => {
        const allImgs = imageDiv.querySelectorAll('img');
        console.error(`Final check: Found ${allImgs.length} images in DOM`);

        // Force main containers to be visible again (in case something changed)
        imageDiv.style.display = 'block';
        imageDiv.style.visibility = 'visible';

        if (allImgs.length > 0) {
            const firstImg = allImgs[0];
            const rect = firstImg.getBoundingClientRect();
            console.error('First image rect:', {
                width: rect.width,
                height: rect.height,
                top: rect.top,
                left: rect.left,
                visible: rect.width > 0 && rect.height > 0
            });

            // If image has no size, try to force it
            if (rect.width === 0 || rect.height === 0) {
                console.error('Attempting to force image visibility...');
                firstImg.style.minWidth = '200px';
                firstImg.style.minHeight = '200px';
                firstImg.style.border = '2px solid red';
            }
        }

        // Try to ensure any parent container is visible
        let currentElement = imageDiv;
        while (currentElement && currentElement !== document.body) {
            if (currentElement.style) {
                currentElement.style.display = currentElement.style.display === 'none' ? 'block' : currentElement.style.display;
                currentElement.style.visibility = 'visible';
                currentElement.style.opacity = '1';
            }
            currentElement = currentElement.parentElement;
        }

        // Update history if that function exists
        if (typeof loadHistory === 'function') {
            loadHistory(1, false);
        }
    }, 500);
}
// Helper function for image downloads if not already defined
if (typeof downloadImage !== 'function') {
    window.downloadImage = function(url, format) {
        const link = document.createElement('a');
        link.href = url;
        link.download = `image.${format}`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };
}
// Create lightbox for fullscreen image viewing
function createLightbox(imageUrl, variationNumber, prompt) {
    // Create and style lightbox container
    const lightbox = document.createElement('div');
    lightbox.className = 'midjourney-lightbox';
    lightbox.style.position = 'fixed';
    lightbox.style.top = '0';
    lightbox.style.left = '0';
    lightbox.style.width = '100%';
    lightbox.style.height = '100%';
    lightbox.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
    lightbox.style.display = 'flex';
    lightbox.style.flexDirection = 'column';
    lightbox.style.alignItems = 'center';
    lightbox.style.justifyContent = 'center';
    lightbox.style.zIndex = '9999';
    lightbox.style.opacity = '0';
    lightbox.style.transition = 'opacity 0.3s ease';

    // Lightbox header
    const lightboxHeader = document.createElement('div');
    lightboxHeader.style.position = 'absolute';
    lightboxHeader.style.top = '0';
    lightboxHeader.style.left = '0';
    lightboxHeader.style.width = '100%';
    lightboxHeader.style.padding = '16px';
    lightboxHeader.style.display = 'flex';
    lightboxHeader.style.justifyContent = 'space-between';
    lightboxHeader.style.alignItems = 'center';
    lightboxHeader.style.boxSizing = 'border-box';
    lightboxHeader.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';

    // Prompt and variation info
    const lightboxInfo = document.createElement('div');
    lightboxInfo.style.color = '#fff';

    const lightboxPrompt = document.createElement('div');
    lightboxPrompt.textContent = prompt || 'Generated Image';
    lightboxPrompt.style.fontSize = '14px';
    lightboxPrompt.style.fontWeight = '500';
    lightboxPrompt.style.marginBottom = '4px';

    const lightboxVariation = document.createElement('div');
    lightboxVariation.textContent = `Variation ${variationNumber}`;
    lightboxVariation.style.fontSize = '12px';
    lightboxVariation.style.color = 'rgba(255, 255, 255, 0.7)';

    lightboxInfo.appendChild(lightboxPrompt);
    lightboxInfo.appendChild(lightboxVariation);

    // Close button
    const lightboxClose = document.createElement('button');
    lightboxClose.innerHTML = '×';
    lightboxClose.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
    lightboxClose.style.color = '#fff';
    lightboxClose.style.border = 'none';
    lightboxClose.style.borderRadius = '50%';
    lightboxClose.style.width = '36px';
    lightboxClose.style.height = '36px';
    lightboxClose.style.fontSize = '24px';
    lightboxClose.style.display = 'flex';
    lightboxClose.style.alignItems = 'center';
    lightboxClose.style.justifyContent = 'center';
    lightboxClose.style.cursor = 'pointer';
    lightboxClose.style.transition = 'background-color 0.2s ease';

    lightboxClose.addEventListener('mouseenter', () => {
        lightboxClose.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
    });

    lightboxClose.addEventListener('mouseleave', () => {
        lightboxClose.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
    });

    lightboxClose.addEventListener('click', () => {
        lightbox.style.opacity = '0';
        setTimeout(() => {
            document.body.removeChild(lightbox);
        }, 300);
    });

    // Image container
    const lightboxImageContainer = document.createElement('div');
    lightboxImageContainer.style.maxWidth = '90%';
    lightboxImageContainer.style.maxHeight = '80%';
    lightboxImageContainer.style.display = 'flex';
    lightboxImageContainer.style.alignItems = 'center';
    lightboxImageContainer.style.justifyContent = 'center';

    // Image element
    const lightboxImage = document.createElement('img');
    lightboxImage.src = imageUrl;
    lightboxImage.alt = `Variation ${variationNumber}`;
    lightboxImage.style.maxWidth = '100%';
    lightboxImage.style.maxHeight = '100%';
    lightboxImage.style.objectFit = 'contain';
    lightboxImage.style.borderRadius = '4px';
    lightboxImage.style.boxShadow = '0 5px 25px rgba(0, 0, 0, 0.5)';

    // Download button
    const lightboxDownload = document.createElement('div');
    lightboxDownload.style.position = 'absolute';
    lightboxDownload.style.bottom = '20px';
    lightboxDownload.style.right = '20px';

    const downloadBtn = document.createElement('button');
    downloadBtn.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 8px;">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
        Télécharger
    `;
    downloadBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
    downloadBtn.style.color = '#fff';
    downloadBtn.style.border = 'none';
    downloadBtn.style.borderRadius = '4px';
    downloadBtn.style.padding = '8px 16px';
    downloadBtn.style.fontSize = '14px';
    downloadBtn.style.display = 'flex';
    downloadBtn.style.alignItems = 'center';
    downloadBtn.style.cursor = 'pointer';
    downloadBtn.style.transition = 'background-color 0.2s ease';

    downloadBtn.addEventListener('mouseenter', () => {
        downloadBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
    });

    downloadBtn.addEventListener('mouseleave', () => {
        downloadBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
    });

    downloadBtn.addEventListener('click', () => {
        if (typeof downloadImage === 'function') {
            downloadImage(imageUrl, 'png');
        } else {
            window.open(imageUrl, '_blank');
        }
    });

    // Close lightbox when clicking the background
    lightbox.addEventListener('click', (e) => {
        if (e.target === lightbox) {
            lightbox.style.opacity = '0';
            setTimeout(() => {
                document.body.removeChild(lightbox);
            }, 300);
        }
    });

    // Assemble elements
    lightboxHeader.appendChild(lightboxInfo);
    lightboxHeader.appendChild(lightboxClose);

    lightboxImageContainer.appendChild(lightboxImage);

    lightboxDownload.appendChild(downloadBtn);

    lightbox.appendChild(lightboxHeader);
    lightbox.appendChild(lightboxImageContainer);
    lightbox.appendChild(lightboxDownload);

    // Add to body and show
    document.body.appendChild(lightbox);

    // Force layout calculation before adding opacity transition
    void lightbox.offsetWidth;

    // Show lightbox with transition
    lightbox.style.opacity = '1';
}


// Helper function to test the display with mock data
function testMidjourneyDisplay() {
    console.error('DEBUG: Testing display with mock data');

    // Create mock data similar to your real data
    const mockData = {
        prompt: "Test prompt for debugging",
        timestamp: new Date().toISOString(),
        images: [
            {
                choice: 1,
                url: "/static/assets/img/placeholder.png", // Use a known good image
                variation_number: 1,
                width: 1024,
                height: 1024
            },
            {
                choice: 2,
                url: "/static/assets/img/placeholder.png",
                variation_number: 2,
                width: 1024,
                height: 1024
            },
            {
                choice: 3,
                url: "/static/assets/img/placeholder.png",
                variation_number: 3,
                width: 1024,
                height: 1024
            },
            {
                choice: 4,
                url: "/static/assets/img/placeholder.png",
                variation_number: 4,
                width: 1024,
                height: 1024
            }
        ]
    };

    // Call the debug display function
    displayMidjourneyGroup(mockData);
}

// To use this debug version, add this line to your JavaScript:
// Replace your call to displayMidjourneyGroup with displayMidjourneyGroupDebug
// Or run testMidjourneyDisplay() from the console to test with mock data

function updateProgressIndicator(percentage) {
    const progressBar = document.querySelector('.progress-bar');
    if (!progressBar) {
        const progressContainer = document.createElement('div');
        progressContainer.className = 'progress-container mt-4';
        progressContainer.innerHTML = `
            <div class="w-full bg-gray-200 rounded-full h-2.5" style="background-color: rgba(255,255,255,0.1); height: 6px; border-radius: 3px; overflow: hidden;">
                <div class="progress-bar bg-blue-600 h-2.5 rounded-full transition-all duration-500"
                     style="background-color: #8e78ff; height: 100%; width: ${percentage}%; transition: width 0.5s ease;"></div>
            </div>
            <div class="text-sm mt-2" style="color: rgba(255,255,255,0.7); font-size: 12px; text-align: center; margin-top: 8px;">
                Génération en cours : ${Math.round(percentage)}%
            </div>
        `;
        document.getElementById('generated-image').appendChild(progressContainer);
    } else {
        progressBar.style.width = `${percentage}%`;
        const textEl = progressBar.parentElement.nextElementSibling;
        if (textEl) {
            textEl.textContent = `Génération en cours : ${Math.round(percentage)}%`;

            // Ajouter un effet pulse quand la progression change
            textEl.classList.add('progress-pulse');
            setTimeout(() => {
                textEl.classList.remove('progress-pulse');
            }, 500);
        }
    }
}
function showImageDetail(image, prompt) {
    // Get token for URLs
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');

    // Ensure we have a valid URL and choice number
    const imageUrl = image.url || '';
    const fullImageUrl = imageUrl.includes('token=') ? imageUrl :
        `${imageUrl}${imageUrl.includes('?') ? '&' : '?'}token=${encodeURIComponent(token)}`;

    const choiceNum = typeof image.choice === 'number' ? image.choice :
                     (typeof image.variation_number === 'number' ? image.variation_number : 0);

    const modal = document.createElement('div');
    modal.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50';
    modal.innerHTML = `
        <div class="bg-white w-full max-w-4xl rounded-lg p-4">
            <div class="flex justify-between items-center mb-4">
                <div>
                    <h3 class="text-xl font-semibold">Variation ${image.choice}</h3>
                    <p class="text-sm text-gray-600">${prompt}</p>
                </div>
                <button class="close-button text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <img src="${fullImageUrl}"
                 alt="Variation ${choiceNum + 1}"
                 class="w-full rounded-lg">
            <div class="mt-4 flex justify-between items-center">
                <div class="text-sm text-gray-600">
                    ${image.width || 1024}x${image.height || 1024}
                </div>
                <div class="dropdown">
                    <button class="fn__icon_button dropdown-toggle">
                        <img src="/static/assets/svg/download.svg" alt="" class="fn__svg">
                    </button>
                    <ul class="dropdown-menu dropdown-menu-dark">
                        <li class="dropdown-item" data-format="png" data-url="${fullImageUrl}">PNG</li>
                        <li class="dropdown-item" data-format="jpg" data-url="${fullImageUrl}">JPG</li>
                        <li class="dropdown-item" data-format="jpeg" data-url="${fullImageUrl}">JPEG</li>
                    </ul>
                </div>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    modal.querySelector('.close-button').addEventListener('click', () => {
        modal.remove();
    });

    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.remove();
        }
    });

    modal.addEventListener('click', (e) =>{
        if (e.target === modal) {
            modal.remove();
        }
    });
    // Set up download buttons
    modal.querySelectorAll('.dropdown-item').forEach(item => {
        item.addEventListener('click', (e) => {
            const format = e.target.getAttribute('data-format');
            const url = e.target.getAttribute('data-url');
            if (format && url) {
                downloadImage(url, format);
            }
        });
    });
}

function showErrorOverlay(title, message) {
    console.error(title, message);
    alert(`${title}: ${message}`);

    let errorOverlay = document.getElementById('error-overlay');
    if (!errorOverlay) {
        errorOverlay = document.createElement('div');
        errorOverlay.id = 'error-overlay';
        errorOverlay.style.position = 'fixed';
        errorOverlay.style.top = '20px';
        errorOverlay.style.left = '50%';
        errorOverlay.style.transform = 'translateX(-50%)';
        errorOverlay.style.backgroundColor = 'rgba(220, 53, 69, 0.9)';
        errorOverlay.style.color = 'white';
        errorOverlay.style.padding = '15px 20px';
        errorOverlay.style.borderRadius = '5px';
        errorOverlay.style.zIndex = '9999';
        errorOverlay.style.maxWidth = '80%';
        errorOverlay.style.textAlign = 'center';
        document.body.appendChild(errorOverlay);
    }

    // Déterminer le message en fonction du type d'erreur
    let errorMessage = message;

    if (message.includes("token") || message.includes("Token") || title.includes("token") || title.includes("Token")) {
        errorMessage = "Vous n'avez pas assez de tokens pour cette opération. <a href='/pricing.html' style='color:white;text-decoration:underline;'>Mettez à niveau votre abonnement</a> pour obtenir plus de tokens.";
    } else if (message.includes("403") || message.includes("Forbidden")) {
        errorMessage = "Accès refusé. Veuillez vous assurer que vous êtes correctement connecté.";
    } else if (message.includes("500") || message.includes("serveur")) {
        errorMessage = "Erreur interne du serveur. Notre équipe a été notifiée et travaille sur le problème. Veuillez réessayer plus tard.";
    }

    errorOverlay.innerHTML = `
        <div>
            <strong>${title}</strong><br>
            ${errorMessage}
        </div>
        <div style="margin-top:10px;">
            <button onclick="document.getElementById('error-overlay').style.display='none'"
                    style="background:white;color:#dc3545;border:none;padding:5px 10px;border-radius:3px;cursor:pointer;">
                Fermer
            </button>
        </div>
    `;

    // Faire disparaître le message après 5 secondes
    setTimeout(() => {
        if (errorOverlay && errorOverlay.parentNode) {
            errorOverlay.style.opacity = '0';
            errorOverlay.style.transition = 'opacity 0.5s ease';
            setTimeout(() => {
                if (errorOverlay && errorOverlay.parentNode) {
                    errorOverlay.parentNode.removeChild(errorOverlay);
                }
            }, 500);
        }
    }, 5000);
}

    function saveInstance(prompt, imageUrl) {
        instances.push({ prompt, imageUrl });
    }

    // function addImageToSidebar(url, index) {
    //     const sidebar = document.getElementById('sidebar');
    //     const thumbnail = document.createElement('img');
    //     thumbnail.src = url;
    //     thumbnail.onclick = () => displayInstance(index);
    //     sidebar.insertBefore(thumbnail, sidebar.querySelector('.new-image').nextSibling);
    // }

    function addImageToSidebar(url, index) {
        const sidebar = document.getElementById('sidebar');

        const listItem = `
            <li class="fn__gl_item">
                <div class="fn__gl__item">
                    <div class="abs_item">
                        <img src="${url}" alt="Image ${index}" onclick="displayInstance(${index})">
                    </div>
                </div>
            </li>
        `;

        sidebar.innerHTML += listItem;
    }

    function displayInstance(index) {
        const { prompt, imageUrl } = instances[index];
        const promptInput = document.getElementById('prompt');
        const imageDiv = document.getElementById('generated-image');
        const downloadSection = document.querySelector('.fn__generation_item .item_list .fn__generation_list');

        promptInput.value = prompt;
        promptInput.disabled = true;
        imageDiv.innerHTML = `<img src="${imageUrl}" class="img-fluid mt-3" alt="Generated Image">`;
        downloadSection.style.display = 'block';
        generatedImageUrl = imageUrl;

        document.getElementById('generate-text').textContent = 'Générer une nouvelle image';

    }
    function createNewInstance() {
        document.getElementById('prompt').value = '';
        document.getElementById('prompt').disabled = false;
        document.getElementById('generated-image').innerHTML = '';
        document.getElementById('download-section').style.display = 'none';
        document.getElementById('generate-text').textContent = 'Générer l\'image';
    }

    function handleGroupClick(taskId) {
        console.error(`Handling click on group ${taskId}`);
        if (!taskId) {
            console.error("No taks ID porvided");
            return;
        }

        const mainContainer = document.getElementById('generated-image');
        if (mainContainer) {
            mainContainer.innerHTML = `
                <div style="display: flex; justify-content: center; align-items: center; min-height: 200px;">
                    <div style="text-align: center;">
                        <div style="border: 3px solid #555; border-top: 3px solid #fff; border-radius: 50%;
                                    width: 30px; height: 30px; margin: 0 auto; animation: spin 1s linear infinite;"></div>
                        <p style="margin-top: 15px; color: #ccc;">Chargement des images...</p>
                    </div>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
        }
        // Get token for authentication
        const urlParams = new URLSearchParams(window.location.search);
        const token = urlParams.get('token');

        // Fetch the task status
        fetch(`/check_midjourney_status/${taskId}?token=${encodeURIComponent(token)}`, {
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        })
        .then(response => response.json())
        .then(data => {
            console.error("Got midjourney status data:", data);
            if (data.success && data.data) {
                // Call the display function with the group data
                displayMidjourneyGroup(data.data);

                // Update other UI elements
                if (document.getElementById('prompt')) {
                    document.getElementById('prompt').value = data.data.prompt || '';
                }

                // Show the download section
                const downloadSection = document.getElementById('download-section');
                if (downloadSection) {
                    downloadSection.style.display = 'block';
                }
            } else {
                console.error("Failed to load midjourney group data");
                if (mainContainer) {
                    mainContainer.innerHTML = `<p style="color: #ff6b6b; text-align: center; padding: 20px;">
                        Impossible de charger les images. Veuillez réessayer.</p>`;
                }
            }
        })
        .catch(error => {
            console.error("Error fetching group data:", error);
            if (mainContainer) {
                mainContainer.innerHTML = `<p style="color: #ff6b6b; text-align: center; padding: 20px;">
                    Erreur lors du chargement des images.</p>`;
            }
        });

    }
    function downloadImage(url, format) {
        console.error('Starting download:', {url, format});
        if (!url) {
            console.error('No URL provided for download');
            alert('URL de téléchargement manquante');
            return;
        }

        const img = new Image();
        img.crossOrigin = 'anonymous';

        // Add loading indicator
        const loadingIndicator = document.createElement('div');
        loadingIndicator.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
        loadingIndicator.innerHTML = `
            <div class="bg-white p-4 rounded">
                <div class="spinner-border" role="status"></div>
                <p class="mt-2">Téléchargement en cours...</p>
            </div>
        `;
        document.body.appendChild(loadingIndicator);

        img.onload = function () {
            console.error('Image loaded successfully');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            canvas.toBlob(function (blob) {
                loadingIndicator.remove();
                if (!blob) {
                    console.error('Failed to create blob');
                    alert('Échec de la création du fichier image');
                    return;
                }
                console.error('Blob created successfully');
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `image.${format.toLowerCase()}`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            }, `image/${format.toLowerCase()}`, 1.0);
        };
        // Gestion des erreurs
        img.onerror = function () {
            console.error('Erreur lors du chargement de l\'image');
            alert('Impossible de télécharger l\'image. Veuillez réessayer.');
        };

        // Set timeout to handle hanging requests
        setTimeout(() => {
            if (!img.complete) {
                loadingIndicator.remove();
                console.error('Image download timed out');
                alert('Le téléchargement a expiré. Veuillez réessayer.');
            }
        }, 20000);

        img.src = url;
    }

    function createHistoryItem(item, delay=0) {
            console.error("creating history with item:", item)
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            const fullImageUrl = `${item.url}?token=${encodeURIComponent(token)}`;
            const listItem = document.createElement('li');
            listItem.className = 'fn__gl_item';

            if (item.model === 'midjourney' && item.images && item.images.length > 0) {
                // Créer un aperçu du groupe Midjourney

                listItem.dataset.taskId = item.task_id || '';

                let thumbnailsHtml = '';

                const imagesToShow = item.images.slice(0, 4);
                imagesToShow.forEach((img, index) => {
                   // Ensure image URL is properly formatted
                    let imageUrl = img.url;
                    if (!imageUrl.startsWith('http') && !imageUrl.startsWith('/')) {
                        imageUrl = `/image/${img.key}`;
                    }
                    if (!imageUrl.includes('token=') && token) {
                        imageUrl += (imageUrl.includes('?') ? '&' : '?') + `token=${encodeURIComponent(token)}`;
                    }

                    thumbnailsHtml += `
                        <div style="width: 50%; height: 50%; padding: 1px; box-sizing: border-box;">
                            <img src="${imageUrl}"
                                 alt="V${index + 1}"
                                 style="width: 100%; height: 100%; object-fit: cover; display: block;">
                        </div>
                    `;
                });

                listItem.innerHTML = `
                    <div class="fn__gl__item">
                        <div class="abs_item">
                            <div style="position: relative; width: 100%; height: 100%; border-radius: 8px; overflow: hidden;">
                                <div style="display: flex; flex-wrap: wrap; width: 100%; height: 100%;">
                                    ${thumbnailsHtml}
                                </div>
                                <div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7);
                                            color: white; padding: 4px; font-size: 10px; text-overflow: ellipsis;
                                            overflow: hidden; white-space: nowrap;">
                                    ${item.prompt || ''}
                                </div>
                            </div>
                        </div>
                    </div>
                `;


                // Gestionnaire d'événements pour l'ouverture du groupe
                listItem.addEventListener('click', () => {
                    handleGroupClick(item.taskId);
                });

            } else {
                listItem.innerHTML = `
                <div class="fn__gl__item">
                    <div class="abs_item">
                        <img src="${fullImageUrl}" alt="Generated image" loading="lazy">
                        <div class="prompt">${item.prompt}</div>
                        <div class="timestamp">${new Date(item.timestamp).toLocaleString()}</div>
                        <!-- Ajout du bouton de téléchargement similaire à celui des nouvelles images -->
                        <div class="all_options">
                            <div class="fn__icon_options medium_size">
                                <div class="dropdown">
                                    <button class="fn__icon_button dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                        <img src="/static/assets/svg/download.svg" alt="" class="fn__svg">
                                    </button>
                                    <ul class="dropdown-menu dropdown-menu-dark">
                                        <li class="dropdown-item" data-format="png" data-url="${fullImageUrl}">PNG</li>
                                        <li class="dropdown-item" data-format="jpg" data-url="${fullImageUrl}">JPG</li>
                                        <li class="dropdown-item" data-format="jpeg" data-url="${fullImageUrl}">JPEG</li>
                                        <li class="dropdown-item" data-format="gif" data-url="${fullImageUrl}">GIF</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;


            // Empêcher la propagation du clic pour les boutons de téléchargement
            const downloadButtons = listItem.querySelectorAll('.dropdown-item, .dropdown-toggle');
            downloadButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const format = button.getAttribute('data-format');
                    const imageUrl = button.getAttribute('data-url');
                    if (format && imageUrl) {
                        downloadImage(imageUrl, format);
                    }
                });
            });

            const img = listItem.querySelector('img');
            img.addEventListener('click', () => {
                const mainImageContainer = document.getElementById('generated-image');
                const downloadSection = document.getElementById('download-section');
                mainImageContainer.innerHTML = `<img src="${fullImageUrl}" class="img-fluid mt-3" alt="Generated Image">`;
                document.getElementById('prompt').value = item.prompt;
                downloadSection.style.display = 'block';
                generatedImageUrl = fullImageUrl;
            });

             // Ajouter le délai d'animation
            listItem.style.animationDelay = `${delay}ms`;

            }

            return listItem;

        }

        // Chargement automatique au scroll
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && hasMore && !isLoading) {
                    loadHistory(currentPage + 1, true);
                }
            });
        }, {
            rootMargin: '100px'
        });
        // Observer le loader
        observer.observe(document.getElementById('historyLoader'));

        // Chargement initial de l'historique
        //document.addEventListener('DOMContentLoaded', () => {
            //loadHistory(1, false);
        //});
    function showMidjourneyDetail(groupData) {
    const detailView = document.createElement('div');
    detailView.className = 'midjourney-detail-view';

    detailView.innerHTML = `
        <div class="midjourney-detail-content">
            <div class="detail-header">
                <h3>${groupData.prompt}</h3>
                <button class="close-button">×</button>
            </div>
            <div class="midjourney-variations-grid">
                ${groupData.images.map((img, index) => `
                    <div class="variation-item">
                        <img src="${img.url}?token=${encodeURIComponent(token)}"
                             alt="Variation ${index + 1}"
                             class="variation-image">
                        <div class="variation-number">V${index + 1}</div>
                        <div class="all_options">
                            <div class="fn__icon_options medium_size">
                                <div class="dropdown">
                                    <button class="fn__icon_button dropdown-toggle" type="button" data-bs-toggle="dropdown">
                                        <img src="/static/assets/svg/download.svg" alt="" class="fn__svg">
                                    </button>
                                    <ul class="dropdown-menu dropdown-menu-dark">
                                        <li class="dropdown-item" data-format="png" data-url="${img.url}">PNG</li>
                                        <li class="dropdown-item" data-format="jpg" data-url="${img.url}">JPG</li>
                                        <li class="dropdown-item" data-format="jpeg" data-url="${img.url}">JPEG</li>
                                        <li class="dropdown-item" data-format="gif" data-url="${img.url}">GIF</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;

    // Fermeture de la vue détaillée
    detailView.querySelector('.close-button').addEventListener('click', () => {
        detailView.remove();
    });

    // Clic sur l'arrière-plan pour fermer
    detailView.addEventListener('click', (e) => {
        if (e.target === detailView) {
            detailView.remove();
        }
    });

    document.body.appendChild(detailView);
}

    // Fonction pour charger l'historique
        async function loadHistory(page = 1, append = false) {
            console.error(`Fetching history for page ${page}...`);
            if (isLoading || (!append && !hasMore)) return;

            const historyLoader = document.getElementById('historyLoader');
            const historyContent = document.querySelector('.generation_history .fn__generation_list.sidebar');

            isLoading = true;
            historyLoader.classList.remove('d-none');

            try {
                const urlParams = new URLSearchParams(window.location.search);
                const token = urlParams.get('token');

                // Utiliser l'endpoint approprié pour votre historique
                const endpoint = '/api/chat/history/generated';
                const url = `${endpoint}?page=${page}&token=${encodeURIComponent(token)}`;

                const response = await fetch(url, {
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });

                if (!response.ok) {
                    if (response.status === 401 || response.status === 403) {
                        window.location.href = LOGIN_URL;
                        return;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.error('Fetched data:', data);

                if (!append) {
                    historyContent.innerHTML = '';
                }

                const items = data.data?.items || [];

                if (items.length > 0) {
                    items.forEach((item, index) => {
                        console.error('Processing item:', {
                            index,
                            rawItem: item,
                            modelFromParams: item.parameters?.model,
                            url: item.url,
                            imageUrl: item.image_url, // Au cas où l'URL serait sous un nom différent
                            prompt: item.prompt,
                            timestamp: item.timestamp
                        });
                       // Normaliser les données selon le modèle
                        const normalizedItem = {
                            url: item.url || item.image_url,
                            prompt: item.prompt,
                            timestamp: item.timestamp,
                            model: item.model || currentModel // Utiliser le modèle courant si non spécifié
                        };

                        // Vérifier que nous avons une URL valide
                        if (!normalizedItem.url) {
                            console.error('Missing URL for item:', normalizedItem);
                            return; // Skip this item
                        }

                        const delay = index * 100;
                        const historyItem = createHistoryItem(normalizedItem, delay);
                        historyContent.appendChild(historyItem);
                    });

                    hasMore = data.data?.pagination?.has_more || false;
                    currentPage = page;

                    // Gestion du bouton "Charger plus"
                    if (hasMore) {
                        if (!document.getElementById('loadMoreBtn')) {
                            const loadMoreBtn = document.createElement('button');
                            loadMoreBtn.id = 'loadMoreBtn';
                            loadMoreBtn.className = 'load-more';
                            loadMoreBtn.textContent = 'Charger plus';
                            loadMoreBtn.onclick = () => loadHistory(currentPage + 1, true);
                            historyContent.after(loadMoreBtn);
                        }
                    } else {
                        const loadMoreBtn = document.getElementById('loadMoreBtn');
                        if (loadMoreBtn) loadMoreBtn.remove();
                    }
                } else {
                    if (!append) {
                        historyContent.innerHTML = '<p class="text-center">Aucun historique disponible</p>';
                    }
                    hasMore = false;
                }

            } catch (error) {
                console.error('Error loading history:', error);
                if (!append) {
                    historyContent.innerHTML = '<p class="text-center text-danger">Erreur lors du chargement de l\'historique</p>';
                }
            } finally {
                isLoading = false;
                historyLoader.classList.add('d-none');
            }
        }
        async function validateImageUrl(imageUrl, token) {
            try {
                const fullUrl = `${imageUrl}?token=${encodeURIComponent(token)}`;
                const response = await fetch(fullUrl, { method: 'HEAD' });

                if (!response.ok) {
                    console.error('Debug - Image validation failed:', response.status);
                    return false;
                }

                const contentType = response.headers.get('content-type');
                return contentType && contentType.startsWith('image/');
            } catch (error) {
                console.error('Debug - Image validation error:', error);
                return false;
            }
        }



        document.addEventListener('DOMContentLoaded', function() {
            // Récupérer le token de l'URL actuelle
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            loadFontAwesome();
            improveTokensDisplay();
            optimizeUpgradeButtons();
            enhanceTokensInfoDisplay();
            const extraStyleElement = document.createElement('style');
            extraStyleElement.textContent = extraStyles;
            document.head.appendChild(extraStyleElement);
            updateTokenCost();


            console.log("Page chargée, initialisation de l'affichage des tokens");
            updateTokensDisplay();

            // Rafraîchir les tokens toutes les 5 minutes
            setInterval(updateTokensDisplay, 5 * 60 * 1000);

            if (token) {
                // Modifier tous les liens de navigation pour inclure le token
                document.querySelectorAll('.neltar_fn_wrapper a').forEach(link => {
                    // Vérifier si c'est un lien interne
                    if (link.href.startsWith(window.location.origin)) {
                        const url = new URL(link.href);
                        url.searchParams.set('token', token);
                        link.href = url.toString();
                    }
                });
                // Modifier tous les formulaires pour inclure le token
                document.querySelectorAll('form').forEach(form => {
                    const input = document.createElement('input');
                    input.type = 'hidden';
                    input.name = 'token';
                    input.value = token;
                    form.appendChild(input);
                });
            }

            document.addEventListener('click', function(event) {
                const dropdownItem = event.target.closest('.dropdown-item');
                if (dropdownItem) {
                    const format = dropdownItem.getAttribute('data-format');
                    const imageUrl = dropdownItem.getAttribute('data-url') || generatedImageUrl;

                    console.log('Download clicked:', {format, imageUrl});

                    if (format && imageUrl) {
                        downloadImage(imageUrl, format);
                        // Fermer le dropdown après la sélection
                        const dropdownMenu = dropdownItem.closest('.dropdown-menu');
                        if (dropdownMenu) {
                            dropdownMenu.classList.remove('show');
                        }
                    }
                }
            });
            const style = document.createElement('style');
            style.textContent = `
                @keyframes progressPulse {
                    0% { opacity: 0.7; }
                    50% { opacity: 1; }
                    100% { opacity: 0.7; }
                }

                .progress-pulse {
                    animation: progressPulse 1s ease;
                }

                @keyframes processingPulse {
                    0% { box-shadow: 0 0 0 0 rgba(142, 120, 255, 0.7); }
                    70% { box-shadow: 0 0 0 10px rgba(142, 120, 255, 0); }
                    100% { box-shadow: 0 0 0 0 rgba(142, 120, 255, 0); }
                }

                .processing-pulse {
                    animation: processingPulse 1.5s infinite;
                }

                .loading-tokens {
                    position: relative;
                }

                .loading-tokens::after {
                    content: '';
                    position: absolute;
                    top: 0;
                    left: 0;
                    right: 0;
                    bottom: 0;
                    background: linear-gradient(90deg, transparent, rgba(142, 120, 255, 0.2), transparent);
                    background-size: 200% 100%;
                    animation: loadingShimmer 1.5s infinite;
                }

                @keyframes loadingShimmer {
                    0% { background-position: -100% 0; }
                    100% { background-position: 100% 0; }
                }
            `;
            document.head.appendChild(style);

            // Intercepter fetch pour les  erreurs d'authentification
            fetch = (originalFetch => {
                return async (...arguments) => {
                    try {
                        const response = await originalFetch(...arguments);
                        if (response.status === 401 || response.status === 403) {
                            const data = await response.json();
                            if (data.redirect_url) {
                                window.location.href = data.redirect_url;
                                return;
                            }
                        }
                        return response;
                    } catch (error) {
                        throw error;
                    }
                };
            })(fetch);

            loadHistory(1, false);
        });
</script>




{% endblock %}

