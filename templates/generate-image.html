{% extends 'base.html' %}

{% block title %}Home Page{% endblock %}

{% block content %}

<style>
    .midjourney-enhanced-container {
        position: relative;
        width: 100%;
        max-width: 1100px;
        margin: 0 auto 20px;
        background-color: #18191d;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    .midjourney-header {
        padding: 16px 20px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .midjourney-prompt {
        flex: 1;
        overflow: hidden;
    }

    .midjourney-prompt h3 {
        font-size: 16px;
        font-weight: 600;
        color: #ffffff;
        margin: 0 0 4px 0;
        text-overflow: ellipsis;
        overflow: hidden;
        white-space: nowrap;
    }

    .midjourney-prompt div {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.5);
    }

    .midjourney-close-btn {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        border: none;
        background-color: rgba(255, 255, 255, 0.1);
        color: rgba(255, 255, 255, 0.7);
        font-size: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s ease;
        margin-left: 10px;
    }

    .midjourney-close-btn:hover {
        background-color: rgba(255, 255, 255, 0.2);
        color: rgba(255, 255, 255, 0.9);
    }

    .midjourney-image-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
        padding: 8px;
    }

    .midjourney-image-card {
        position: relative;
        border-radius: 8px;
        overflow: hidden;
        background-color: #22232a;
        aspect-ratio: 1;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .midjourney-image-card:hover {
        transform: scale(1.02);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    }

    .midjourney-image-card img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
        transition: transform 0.3s ease;
    }

    .midjourney-image-card:hover img {
        transform: scale(1.05);
    }

    .version-badge {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background-color: rgba(0, 0, 0, 0.75);
        color: #fff;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 600;
        letter-spacing: 0.5px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        z-index: 1;
    }

    .image-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0);
        transition: background-color 0.3s ease;
        display: flex;
        flex-direction: column;
        justify-content: flex-start;
        align-items: flex-end;
        padding: 10px;
        box-sizing: border-box;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .midjourney-image-card:hover .image-overlay {
        background-color: rgba(0, 0, 0, 0.2);
        opacity: 1;
    }

    .download-container {
        position: relative;
        z-index: 2;
    }

    .download-button {
        background-color: rgba(0, 0, 0, 0.75);
        border: none;
        border-radius: 4px;
        color: #fff;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        transition: background-color 0.2s ease;
    }

    .download-button:hover {
        background-color: rgba(0, 0, 0, 0.9);
    }

    .format-dropdown {
        position: absolute;
        top: 100%;
        right: 0;
        margin-top: 5px;
        background-color: #2a2b31;
        border-radius: 4px;
        overflow: hidden;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
        display: none;
        z-index: 3;
    }

    .format-option {
        padding: 8px 16px;
        cursor: pointer;
        color: #fff;
        transition: background-color 0.2s ease;
        font-size: 12px;
    }

    .format-option:hover {
        background-color: #3a3b42;
    }

    .success-message {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 12px;
        background-color: rgba(0, 200, 83, 0.15);
        color: #00c853;
        border-top: 1px solid rgba(0, 200, 83, 0.2);
        overflow: hidden;
        transition: all 0.5s ease-out;
    }

    .success-message svg {
        margin-right: 8px;
    }

    /* Lightbox styles */
    .midjourney-lightbox {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.9);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 9999;
        opacity: 0;
        transition: opacity 0.3s ease;
    }

    .midjourney-group {
        position: relative;
        width: 100%;
        max-width: 400px;
        cursor: pointer;
    }

    .midjourney-group-preview {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 2px;
        border-radius: 8px;
        overflow: hidden;
    }

    .midjourney-group-preview img {
        width: 100%;
        height: auto;
        object-fit: cover;
    }

    .midjourney-group-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.3);
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: opacity 0.3s;
    }

    .midjourney-group:hover .midjourney-group-overlay {
        opacity: 1;
    }

    .midjourney-detail-view {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.9);
        z-index: 1000;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .midjourney-detail-content {
        width: 90%;
        max-width: 1200px;
        background: #fff;
        border-radius: 12px;
        padding: 20px;
    }

    .midjourney-variations-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 16px;
        margin-top: 20px;
    }

    .variation-item {
        position: relative;
        cursor: pointer;
        transition: transform 0.2s;
    }

    .variation-item:hover {
        transform: scale(1.02);
    }

    .variation-number {
        position: absolute;
        bottom: 8px;
        left: 8px;
        background: rgba(0, 0, 0, 0.6);
        color: white;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
    }
     .spinner-border {
            width: 2rem;
            height: 2rem;
            color: #333;
            margin-top: 20px;
            display: none;
        }

    .dropdown-item{
        cursor: pointer
    }
    #download-section {
            display: none;
        }
    .midjourney-group-container {
        @apply p-4;
    }

    .progress-container {
        @apply mt-4 mb-8;
    }

    .variation-number {
        @apply absolute bottom-2 left-2 bg-black bg-opacity-50 text-white px-2 py-1 rounded text-sm;
    }

    .image-actions {
        @apply absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity;
    }
    .generation-status {
        padding: 2rem;
        text-align: center;
    }

    .initial-grid {
        position: relative;
        overflow: hidden;
        border-radius: 0.5rem;
        margin-bottom: 2rem;
    }

    .initial-grid img {
        width: 100%;
        height: auto;
    }

    #upscale-progress {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 1rem;
        margin-top: 2rem;
    }

    .upscale-slot {
        position: relative;
        aspect-ratio: 1/1;
        background: #f3f4f6;
        border-radius: 0.5rem;
        overflow: hidden;
    }

    .progress-container {
        width: 100%;
        height: 4px;
        background: #e5e7eb;
        border-radius: 2px;
        overflow: hidden;
    }

    .progress-bar {
        height: 100%;
        background: #3b82f6;
        transition: width 0.3s ease;
    }
    @keyframes tokenChange {
        0% { transform: scale(1); }
        50% { transform: scale(1.2); color: #00c853; }
        100% { transform: scale(1); }
    }

    .token-change {
        animation: tokenChange 0.5s ease-in-out;
    }

    .tokens-info {
        margin-right: 10px;
        color: rgba(255, 255, 255, 0.7);
        font-size: 14px;
    }

    .tokens-count {
        font-weight: bold;
        color: #fff;
    }

    .error-message {
        transition: all 0.3s ease;
    }
</style>
<div class="neltar_fn_page">

    <!-- Image Generation Page -->
    <div class="neltar_fn_image_generation_page">

        <div class="generation__page">

            <!-- Generation Header -->
            <div class="generation_header">
                <div class="header_top">
                    <h1 class="title">Image Generation</h1>
                    <div class="setup">
                        <p class="info">This wil use <span class="token-cost" data-model="dall-e">20</span> tokens</p>
                        <div class="token-info">
                            <span class="token_summary">
                                <span class="count">--</span>
                                <span class="text">Tokens<br>Remain</span>
                            </span>
                            <a href="pricing.html" class="token_upgrade neltar_fn_button"><span>Upgrade</span></a>
                            <div class="token__popup">
                                Resets in <span>--</span><br>
                                Daily limit is <span>--</span>
                            </div>
                        </div>
                        <a href="#" class="sidebar__trigger">
                            <img src="{{ url_for('static', filename='assets/svg/option.svg') }}" alt="" class="fn__svg">
                        </a>
                    </div>
                </div>
                <div class="header_bottom">
                    <form id="generate-image-form">

                    <div class="include_area">
                        <textarea  id="prompt" placeholder="Entrez une description" required rows="1"></textarea>

                    </div>

                    <div class="generate_section">

                        <button type="submit" id="generate_it" href="#" class="neltar_fn_button btn btn-link">
                            <span id="generate-text">Générer l'image</span>
                            <div class="spinner-border" id="spinner" role="status"></div>
                        </button>
                    </div>
                </form>

                </div>


            </div>

            <div class="generation_history"  id="download-section">

                <!-- Ajoutez ces éléments dans  HTML -->

                <div id="historyLoader" class="text-center d-none">
                    <div class="spinner-border" role="status">
                        <span class="sr-only">Chargement...</span>
                    </div>
                </div>
                <div id="historyContent" class="fn__generation_list">
                    <!-- L'historique sera chargé ici -->
                </div>

                <div class="fn__generation_item">

                    <div class="item_list">
                        <ul class="fn__generation_list" style="justify-content: center;">
                            <li class="fn__gl_item" style="width: 400px;">
                                <div class="fn__gl__item">

                                    <div class="abs_item">

                                        <div id="generated-image">
                                            <!-- <img src="{{ url_for('static', filename='assets/img/gallery/1.jpg') }}" alt=""> -->

                                        </div>
                                        <div class="all_options">
                                            <div class="fn__icon_options medium_size">

                                                <div class="dropdown">
                                                    <button class="fn__icon_button dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                                        <img src="{{ url_for('static', filename='assets/svg/download.svg') }}" alt="" class="fn__svg">
                                                    </button>
                                                    <ul class="dropdown-menu dropdown-menu-dark">

                                                      <li class="dropdown-item" data-format="png">PNG</li>
                                                      <li class="dropdown-item" data-format="jpg">JPG</li>
                                                      <li class="dropdown-item" data-format="jpeg">JPEG</li>
                                                      <li class="dropdown-item" data-format="gif">GIF</li>

                                                    </ul>
                                                  </div>
                                            </div>

                                        </div>
                                    </div>
                                </div>
                            </li>

                        </ul>
                    </div>

                </div>

            </div>

            <div class="generation_history">

                <div class="fn__generation_item">
                    <div class="item_header">
                        <div class="title_holder">
                            <h2 class="prompt_title">Images History</h2>
                        </div>
                        <div class="item_options">
                            <div class="fn__icon_options medium_size align_right">
                                <a href="javascript:;" class="fn__icon_button" onclick="createNewInstance()">
                                    <img src="{{ url_for('static', filename='assets/svg/plus.svg') }}" alt="" class="fn__svg">
                                </a>

                            </div>

                        </div>
                    </div>
                    <div class="item_list">
                        <ul class="fn__generation_list sidebar" id="sidebar">

                            <!-- <li class="fn__gl_item">
                                <div class="fn__gl__item">
                                    <div class="abs_item">
                                            <img src="img/gallery/1.jpg" alt="">
                                    </div>
                                </div>
                            </li> -->


                        </ul>
                    </div>
                </div>

            </div>

        </div>

        <div class="generation__sidebar">
            <div class="sidebar_model">
                <div class="fn__select_model">
                    <a class="model_open">
                        <img class="user_img" src="{{ url_for('static', filename='assets/img/user/user.jpg') }}" alt="">
                        <div class="author">
                            <h4 class="subtitle">Model</h4>
                            <h3 class="title">GPT 4o</h3>
                        </div>
                        <span class="fn__icon_button">
                            <img src="{{ url_for('static', filename='assets/svg/arrow.svg') }}" alt="" class="fn__svg">
                        </span>
                    </a>
                    <div class="all_models">
                        <ul>
                            <li><a class="selected" href="#">GPT 4o</a></li>
                            <li><a href="#">Midjourney</a></li>

                        </ul>
                    </div>
                </div>
            </div>
            <div class="sidebar_details">
                <div class="number_of_images">
                    <h4 class="title">Number of Images</h4>
                    <div class="fn__quantity">
                        <a href="#" class="decrease"></a>
                        <input type="number" value="1" max="20" min="1">
                        <a href="#" class="increase"></a>
                    </div>
                </div>
                <div class="img_sizes">
                    <h4 class="title">Image Dimensions</h4>
                    <div class="img_size_select">
                        <select>
                            <option value="512_512" selected="">512 x 512px</option>
                            <option value="768_768">768 x 768px</option>
                            <option value="512_1024">512 x 1024px</option>
                            <option value="768_1024">768 x 1024px</option>
                            <option value="1024_1024">1024 x 1024px</option>
                        </select>
                    </div>
                </div>
                <div class="guidance_scale">
                    <h4 class="title">Image Dimensions<span class="fn__tooltip" title="Select the resoultion of the images."><img src="{{ url_for('static', filename='assets/svg/question.svg') }}" alt="" class="fn__svg"></span></h4>
                    <div class="fn__range">
                        <div class="range_in">
                            <input type="range" min="1" max="40" value="7">
                            <div class="slider"></div>
                        </div>
                        <div class="value">7</div>
                    </div>
                </div>
                <div class="prompt_magic_switcher">
                    <h4 class="title"><label for="prompt_switcher">Prompt Magic</label><span class="fn__tooltip" title="TechWave Prompt v3.0. Our custom render pipeline which has much faster compliance and can improve the result with any model selected. Applies a 2x multiplier to accepted costs due to higher GPU overhead."><img src="{{ url_for('static', filename='assets/svg/question.svg') }}" alt="" class="fn__svg"></span></h4>
                    <label class="fn__toggle">
                        <span class="t_in">
                            <input type="checkbox" checked="" id="prompt_switcher">
                            <span class="t_slider"></span>
                            <span class="t_content"></span>
                        </span>
                    </label>
                </div>
                <div class="contrast_switcher">
                    <h4 class="title"><label for="contrast_switcher">High Contrast</label><span class="fn__tooltip" title="If your photo consists of extremely bright and dark areas, then it's considered high contrast. When it has a wide range of tones that go from pure white to pure black, it's medium contrast. No pure whites or blacks and a range of middle tones means it's low contrast."><img src="{{ url_for('static', filename='assets/svg/question.svg') }}" alt="" class="fn__svg"></span></h4>
                    <label class="fn__toggle">
                        <span class="t_in">
                            <input type="checkbox" id="contrast_switcher">
                            <span class="t_slider"></span>
                            <span class="t_content"></span>
                        </span>
                    </label>
                </div>
            </div>
        </div>


    </div>
    <!-- !Image Generation Page -->

</div>

<script>
const LOGIN_URL = "{{ LOGIN_URL }}";

    document.querySelectorAll('.neltar_fn_wrapper').forEach(element => {
    element.classList.add('fn__has_sidebar');
});

    let currentModel = 'dall-e';
    let generatedImageUrl = '';
    const instances = [];

    //ajout supplémentaire !
    let currentPage = 1;
    let isLoading = false;
    let hasMore = true;

    // Écouteur pour le changement de modèle
    document.querySelectorAll('.all_models a').forEach(modelLink => {
        modelLink.addEventListener('click', function(e) {
            e.preventDefault();
            const modelName = this.textContent.toLowerCase();
            currentModel = modelName.includes('gpt') ? 'dall-e' : 'midjourney';
            console.error('model en question:', modelName)

            // Mise à jour visuelle
            document.querySelectorAll('.all_models a').forEach(link => {
                link.classList.remove('selected');
            });
            this.classList.add('selected');

            // Mise à jour du titre affiché
            document.querySelector('.model_open .title').textContent = this.textContent;
        });
    });

    document.getElementById('generate-image-form').addEventListener('submit', async function(event) {
        event.preventDefault();
        const promptInput = document.getElementById('prompt');
        const promptText = promptInput.value;
        const spinner = document.getElementById('spinner');
        const generateText = document.getElementById('generate-text');
        const downloadSection = document.querySelector('.fn__generation_item .item_list .fn__generation_list');
        const imageDiv = document.getElementById('generated-image');
        console.error('Elements exists:', {
            imageDiv: !!imageDiv,
            downloadSection: !! downloadSection
        });

        console.error('Current Model:', currentModel);
        console.error('Prompt:', promptInput.value);

        // Get the token from URL
        const urlParams = new URLSearchParams(window.location.search);
        const token = urlParams.get('token');

        promptInput.disabled = true;
        spinner.style.display = 'inline-block';
        generateText.style.display = 'none';
        downloadSection.style.display = 'none';

        try {
            updateLoadingState('loading');
            const response = await fetch(`/generate_image?token=${encodeURIComponent(token)}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'X-Requested-With': 'XMLHttpRequest'  // This identifies it as an AJAX request
                },
                body: `prompt=${encodeURIComponent(promptInput.value)}&model=${encodeURIComponent(currentModel)}`
            });
            const responseClone = response.clone();

            let result;
            try {
                result = await response.json();
                } catch (jsonError) {
                console.error("Erreur lors du parsing JSON:", jsonError);
                // Si le parsing JSON échoue, on travaille avec le statut de la réponse
                result = { success: false, error: "Erreur de format de réponse" };
            }

            // Handle token expiration and other auth errors
            if(response.status === 401 || response.status === 403){
                if(result && result.error === "Insufficient tokens") {
                    // Afficher un message spécifique pour tokens insuffisants
                    document.getElementById('token-error').style.display = 'block';
                    document.getElementById('token-error').innerHTML = `
                        <strong>Tokens insuffisants</strong><br>
                        Vous n'avez pas assez de tokens pour cette opération.
                        <a href="/pricing.html">Mettez à niveau votre abonnement</a> pour obtenir plus de tokens.
                    `;
                    updateLoadingState('default');
                    return;
                } else {
                    showErrorOverlay(
                    response.status === 401 ? 'Session Expirée' : 'Erreur d\'authentification',
                    result.message || 'Veuillez vous reconnecter.'
                );
                // Redirect after 3 seconds
                 setTimeout(() => {
                     window.location.href = result.redirect_url || LOGIN_URL;
                 }, 3000);
                 return;
                }
            }


            if (result.success) {
                if (currentModel === 'midjourney' && result.status === 'processing') {
                    console.error('Starting Midjourney processing with task_id:', result.task_id);
                    // Cas Midjourney : attente du résultat
                    // Afficher un état initial de chargement
                    updateLoadingState('processing');
                    displayInitialLoadingState();
                    handleMidjourneyProcessing(result.task_id, token, promptText);
                } else {
                    // Cas DALL-E ou réponse immédiate
                    console.error('Displaying generated image:', result.image_url);
                    displayGeneratedImage(result.image_url);

                    if (result.tokens_remaining !== undefined) {
                        updateTokensDisplay(result.tokens_remaining);
                    }
                }
            } else {
                showErrorOverlay('Erreur', result.error || 'Une erreur est survenue');
            }
        } catch (error) {
            console.error('Error:', error);
            showErrorOverlay('Erreur', 'Impossible de contacter le serveur. Veuillez réessayer plus tard.');
        } finally {
            // Réactive l'interface
            spinner.style.display = 'none';
            generateText.style.display = 'inline';
            promptInput.disabled = false;
        }
    });

    // Fonction de gestion du traitement Midjourney
async function handleMidjourneyProcessing(taskId, token) {
    console.error('=== Starting Midjourney Polling ===');
    console.error('Task ID:', taskId);
    const generateText = document.getElementById('generate-text');
    generateText.textContent = 'Génération en cours...';


    let lastImagesCount = 0;
    const maxAttempts = 30;
    let attempts = 0;

    while (attempts < maxAttempts) {
        console.error(`Polling attempt ${attempts + 1}/${maxAttempts}`);
        try {
            console.error('Sending request with model:', currentModel);
            // Ajouter un timeout à la requête fetch
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 secondes

            const statusResponse = await fetch(`/check_midjourney_status/${taskId}?token=${encodeURIComponent(token)}`, {
                headers: {
                    'X-Requested-With': 'XMLHttpRequest'
                },
                signal: controller.signal
            });

            clearTimeout(timeoutId)
            console.error('Status response:', statusResponse.status);

            // Ajoutez ces logs pour déboguer
            console.error(`Requested URL: /check_midjourney_status/${taskId}?token=[redacted]`);
            console.error(`taskId value: ${taskId}`);
            console.error(`taskId type: ${typeof taskId}`);

            if (!statusResponse.ok) {
                console.error(`Response not OK: ${statusResponse.status}`);
                // Tenter de lire le corps de la réponse pour plus d'informations
                try {
                    const errorText = await statusResponse.text();
                    console.error(`Error response body: ${errorText}`);
                } catch (readError) {
                    console.error(`Could not read error response: ${readError}`);
                }
                throw new Error('Erreur lors de la vérification du statut');
            }

            const statusResult = await statusResponse.json();
            console.error('Status data:', statusResult);

            // Mise à jour de la progression si disponible
            if (statusResult.success && statusResult.data) {
                const data = statusResult.data;

                // Si nous avons la grille initiale, l'afficher
                if (data.initial_grid && !document.querySelector('.initial-grid')) {
                    displayInitialGrid(data.initial_grid);
                }

                // Mettre à jour la progression des upscales
                if (data.images && Array.isArray(data.images) && data.images.length > lastImagesCount) {
                    // Check if we have new images to show progress
                    if (data.images.length > lastImagesCount) {
                        lastImagesCount = data.images.length;
                        updateUpscaleProgress(data.images);
                    }
                }

                // Si le groupe est complet
                if ((data.status === 'completed' || data.group_status ==='completed') && (data.images && data.images.length >=4)) {
                    console.error('Group complete, displaying results');
                    displayMidjourneyGroup(data);
                    console.error('call displayMidjourneyGroup');
                    updateLoadingState('complete');
                    return;
                } else if (data.images && data.images.length >=4) {
                    // If we have all 4 images but status isn't marked complete, show them anyway
                    console.error('All 4 images received, displaying anyway');
                    displayMidjourneyGroup(data);
                    updateLoadingState('complete');
                    return;
                }

                // Mettre à jour la barre de progression
                const progress = Math.min(90, (attempts / maxAttempts) * 100);(attempts / maxAttempts) * 100;
                updateProgressIndicator(progress);
            }

            // Gestion des erreurs spécifiques
            if (statusResult.status === 'failed' || statusResult.data?.status === 'failed') {
                showErrorOverlay('Erreur', 'La génération a échoué');
                updateLoadingState('default');
                return;
            }

            const delay = attempts < 5 ? 5000 : 10000;
            await new Promise(resolve => setTimeout(resolve, delay));
            attempts++;

        } catch (error) {
            console.error('Error in polling:', error);
            if (attempts === maxAttempts - 1) {
                showErrorOverlay('Erreur', 'Erreur lors de la vérification du statut');
                updateLoadingState('default');
                return;
            }
            await new Promise(resolve => setTimeout(resolve, 2000));
            attempts++;
        }
    }

    showErrorOverlay('Erreur', 'Le délai de génération a été dépassé');
    updateLoadingState('default');
}

// Fonction d'affichage de l'image générée
function displayGeneratedImage(imageUrl, isGroup = false) {
    if (isGroup) {
        // Pour les groupes Midjourney, attendre que toutes les images soient générées
        return;
    }
    console.error('Starting displayGeneratedImage with imageUrl:', imageUrl);

    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');
    console.error('Token retrieved:', token ? 'Token found' : 'No token');

    const fullImageUrl = `${imageUrl}?token=${encodeURIComponent(token)}`;
    console.error('Full image URL constructed:', fullImageUrl);

    generatedImageUrl = fullImageUrl;
    const imageDiv = document.getElementById('generated-image');
    console.error('Image div found:', imageDiv ? 'Yes' : 'No');

    // Utiliser le bon sélecteur pour cibler la liste qui contient l'image
    const downloadSection = document.getElementById('download-section');
    const imageContainer = document.querySelector('.fn__generation_item .item_list .fn__generation_list');

    console.error('Containers found:', {
        imageDiv: !!imageDiv,
        imageContainer: !!imageContainer,
        downloadSection: !!downloadSection
    });


    if (!imageDiv || !downloadSection || !imageContainer) {
        console.error('Image container missing');
        return;
    }
    const newImage = new Image();
    newImage.onload = function () {
        console.error('Test image loaded successfully');

        imageDiv.innerHTML = `
                <div class="abs_item" >
                    <img src="${fullImageUrl}" class="img-fluid mt-3" alt="Generated Image">
                    <div class="all_options">
                        <div class="fn__icon_options medium_size">
                            <div class="dropdown">
                                <button class="fn__icon_button dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                    <img src="/static/assets/svg/download.svg" alt="" class="fn__svg">
                                </button>
                                <ul class="dropdown-menu dropdown-menu-dark">
                                    <li class="dropdown-item" data-format="png" data-url="${fullImageUrl}">PNG</li>
                                    <li class="dropdown-item" data-format="jpg" data-url="${fullImageUrl}">JPG</li>
                                    <li class="dropdown-item" data-format="jpeg" data-url="${fullImageUrl}">JPEG</li>
                                    <li class="dropdown-item" data-format="gif" data-url="${fullImageUrl}">GIF</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>`;

        console.error('Image element present:', !!imageDiv.querySelector('img'));
        console.error('Image src set:', imageDiv.querySelector('img')?.src);

        downloadSection.style.display = 'block';
        imageContainer.style.display = 'block';

        console.error('Download section display style:', downloadSection.style.display);
        console.error('Image container display style:', imageContainer.style.display);

        // 4. Vérifier que l'image est bien visible
        const insertedImg = imageDiv.querySelector('img');
        if (insertedImg) {
            console.error('Image inserted successfully');
            insertedImg.onload = () => console.error('Inserted image loaded')
            insertedImg.onerror = () => console.error('Inserted image failed to load');
        } else {
            console.error('Failed to insert image element');
        }

        document.getElementById('generate-text').textContent = 'Générer une nouvelle image';

        loadHistory(1, false);
    };
    newImage.onerror = function() {
        console.error('Failed to load test image');
        showErrorOverlay('Error', 'impossible to load the image');
    };
    newImage.src = fullImageUrl;
}

// Fonction pour mettre à jour l'affichage des tokens
function updateTokensDisplay() {
    console.log("Début de updateTokenDisplay");

    // Récupérer le token JWT depuis la variable globale
    const jwtToken = window.jwtToken;
    console.log("JWT Token trouvé:", !!jwtToken);

    if (!jwtToken) {
        console.log("Aucun JWT token trouvé");
        return;
    }

    // Récupérer le token d'URL comme fallback si besoin
    const urlParams = new URLSearchParams(window.location.search);
    const urlToken = urlParams.get('token');
    const tokenToUse = jwtToken || urlToken;

    if (!tokenToUse) {
        console.log("Aucun token trouvé");
        return;
    }
    // Appeler l'API pour obtenir les tokens
    console.log("Début appel API /api/user/tokens");
    fetch('/api/user/tokens?token=' + encodeURIComponent(tokenToUse))
        .then(response => {
            if (!response.ok) {
                throw new Error('Erreur réseau: ' + response.status);
            }
            return response.json();
        })
        .then(data => {
            console.log("Token data received:", data); // Debug
            if (data.success) {
                // Mettre à jour l'affichage des tokens
                const tokenCount = document.querySelector('.fn__token_info .count');
                if (tokenCount) {
                    tokenCount.textContent = data.data.tokens_remaining;
                    // Ajouter une animation de changement
                    tokenCount.classList.add('token-change');
                    setTimeout(() => tokenCount.classList.remove('token-change'), 500);
                }

                // Mettre à jour le popup de info tokens (rechargement)
                const tokenPopup = document.querySelector('.token__popup');
                if (tokenPopup && data.data.next_refill) {
                    const nextRefill = new Date(data.data.next_refill);
                    const now = new Date();

                    // Calculer le temps restant
                    const diffInHours = Math.max(0, Math.round((nextRefill - now) / (1000 * 60 * 60)));

                    tokenPopup.innerHTML = `
                        Resets in <span>${diffInHours} hours</span><br>
                        Daily limit is <span>${data.data.token_limit || 150} tokens</span>
                    `;
                }
            } else {
                console.error("Erreur lors de la récupération des tokens:", data.error);
            }
        })
        .catch(error => {
            console.error('Error fetching token data:', error);
        });
}

// Mettre à jour le coût affiché en fonction du modèle sélectionné
function updateTokenCost() {
    const tokenCostElement = document.querySelector('.token-cost');
    if (tokenCostElement) {
        const costs = {
            'dall-e': 20,
            'midjourney': 30
        };
        tokenCostElement.textContent = costs[currentModel] || 20;
    }
}

// Ajouter un écouteur pour les changements de modèle
document.querySelectorAll('.all_models a').forEach(modelLink => {
    modelLink.addEventListener('click', function() {
        // Le code existant reste inchangé

        // Ajouter cette ligne pour mettre à jour le coût affiché
        updateTokenCost();
    });
});


function calculatePollingDelay(prompt) {
    if (!prompt || typeof prompt !== 'string') {
        console.error('Invalid prompt passed to calculatePollingDelay:', prompt);
        return 5000; // Return default delay if prompt is invalid
    }
    let baseDelay = 7000;
    const maxAdditionalDelay = 15000;
    let complexityScore = 0;

    const wordCount = prompt.split(/\s+/).length;
    if (wordCount > 50) complexityScore += 3;
    else if (wordCount > 30) complexityScore += 2;
    else if (wordCount > 15) complexityScore += 1;

    const complexityIndicators = [
        // Detailed styles and effects
        'realistic', 'photorealistic', 'hyper-realistic', 'detailed', 'intricate',
        'high resolution', 'high detail', '8k', '4k', 'ray tracing', 'volumetric lighting',

        // Complex scene descriptors
        'landscape', 'cityscape', 'panorama', 'scene', 'environment',

        // Multiple subjects
        'group', 'crowd', 'multiple', 'many',

        // Difficult rendering elements
        'reflection', 'glass', 'water', 'mirror', 'transparent', 'translucent',
        'chromatic aberration', 'bokeh', 'depth of field',

        // Specific artistic styles that take longer
        'oil painting', 'watercolor', 'concept art', 'matte painting',

        // Specific lighting conditions
        'sunset', 'sunrise', 'night scene', 'dramatic lighting', 'cinematic',

        // Atmosphere effects
        'fog', 'mist', 'rain', 'snow', 'particles',

        //complex rendering process
        'low angle', 'fisheye', 'first person view', 'a first-person view', 'POV'
    ]

    let indicatorCount = 0;
    complexityIndicators.forEach(indicator =>{
        if (prompt.toLowerCase().includes(indicator.toLowerCase())) {
            indicator++;
        }
    });

    // Add to complexity score based on number of indicators
    if (indicatorCount > 10) complexityScore += 5;
    else if (indicatorCount > 7) complexityScore += 4;
    else if (indicatorCount > 5) complexityScore += 3;
    else if (indicatorCount > 3) complexityScore += 2;
    else if (indicatorCount > 1) complexityScore += 1;

    complexityScore = Math.min(complexityScore, 7); //Max score of 7

    const additionalDelay = Math.min(complexityScore * 2000, maxAdditionalDelay);
    const totalDelay = baseDelay + additionalDelay

    console.log(`Prompt complexity score: ${complexityScore}, Total delay: ${totalDelay}ms`);
    return totalDelay
}

function updateLoadingState(state) {
    const generateText = document.getElementById('generate-text');
    const spinner = document.getElementById('spinner');

    switch(state) {
        case 'loading':
            spinner.style.display = 'inline-block';
            generateText.style.display = 'none';
            break;
        case 'processing':
            spinner.style.display = 'inline-block';
            generateText.textContent = 'Génération en cours...';
            generateText.style.display = 'inline';
            break;
        case 'complete':
            spinner.style.display = 'none';
            generateText.textContent = 'Générer une nouvelle image';
            generateText.style.display = 'inline';
            break;
        default:
            spinner.style.display = 'none';
            generateText.style.display = 'inline';
    }
}
// Nouvelle fonction pour afficher l'état initial
function displayInitialLoadingState() {
    const imageDiv = document.getElementById('generated-image');
    imageDiv.innerHTML = `
        <div class="generation-status">
            <div class="status-message">Génération en cours...</div>
            <div class="progress-container mt-4">
                <div class="progress-bar" style="width: 0%"></div>
            </div>
        </div>
    `;
}

function updateUpscaleProgress(images) {
    if (!Array.isArray(images)) {
        console.error('Expected images array for updateUpscaleProgress, got', images);
        return;
    }
    const progressSection = document.getElementById('upscale-progress') || createUpscaleProgressSection();
    if (!progressSection) {
        console.error('Failed to create or find upscale progress section');
        return;
    }

    images.forEach((image, index) => {
        const imgObj = typeof image === 'string' ? JSON.parse(image) : image;
        console.error(`Processing image ${index}:`, imgObj);

        // Get the variation/upscale number
        const variationNumber = getVariationNumber(image, index)
        const slot = document.querySelector(`#upscale-slot-${variationNumber}`);

        if (slot && image && image.url) {
            // Get the token to append to the URL if needed
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            const fullImageUrl = normalizeImageUrl(image.url, token);

            slot.innerHTML = `
                <img src="${fullImageUrl}" alt="Variation ${variationNumber + 1}"class="w-full h-full object-cover rounded"onerror="this.onerror=null; this.src='/static/assets/img/placeholder.png'; console.error('Failed to load image');">
                <div class="absolute bottom-0 left-0 bg-green-500 text-white px-2 py-1 text-sm rounded-tr">
                    Complété
                </div>
            `;
        }
    });
}

// Nouvelle fonction pour l'affichage de la grille initiale
function displayInitialGrid(imageUrl) {
    const imageDiv = document.getElementById('generated-image');
    const container = document.createElement('div');
    container.className = 'initial-grid mb-4';
    container.innerHTML = `
        <h4 class="text-center mb-2">Génération initiale</h4>
        <div class="relative">
            <img src="${imageUrl}" alt="Initial grid" class="w-full rounded">
            <div class="absolute inset-0 flex items-center justify-center bg-black bg-opacity-50 text-white">
                <span>Génération des variations en cours...</span>
            </div>
        </div>
    `;
    imageDiv.innerHTML = '';
    imageDiv.appendChild(container);
}
// Function to create the upscale progress section if it doesn't exist
function createUpscaleProgressSection() {
    const imageDiv = document.getElementById('generated-image');
    if (!imageDiv) {
        console.error('Cannot find generated-image element');
        return null;
    }
    // Remove existing section if present to avoid duplicates
    const existingSection = document.getElementById('upscale-progress');
    if (existingSection) {
        existingSection.remove();
    }

    const progressSection = document.createElement('div');
    progressSection.id = 'upscale-progress';
    progressSection.className = 'grid grid-cols-2 gap-4 mt-4';

    // Create 4 slots for the 4 upscales
    for (let i = 0; i < 4; i++) {
        const slot = document.createElement('div');
        slot.id = `upscale-slot-${i}`;
        slot.className = 'upscale-slot flex items-center justify-center bg-gray-100';
        slot.innerHTML = `
            <div class="text-gray-400">
                <div class="spinner-border spinner-border-sm" role="status"></div>
                <div class="mt-2">En attente...</div>
            </div>
        `;
        progressSection.appendChild(slot);
    }

    imageDiv.appendChild(progressSection);
    return progressSection;
}

// 1. First, let's create a utility function for consistent URL handling
function normalizeImageUrl(imageUrl, token) {
    if (!imageUrl) return '';

    // If already a full URL
    if (imageUrl.startsWith('http')) {
        // Add token if needed
        if (token && !imageUrl.includes('token=')) {
            return `${imageUrl}${imageUrl.includes('?') ? '&' : '?'}token=${encodeURIComponent(token)}`;
        }
        return imageUrl;
    }

    // If it's a relative URL starting with /
    if (imageUrl.startsWith('/')) {
        const baseUrl = `${window.location.origin}${imageUrl}`;
        return token ? `${baseUrl}${baseUrl.includes('?') ? '&' : '?'}token=${encodeURIComponent(token)}` : baseUrl;
    }

    // Default case
    return token ? `${imageUrl}?token=${encodeURIComponent(token)}` : imageUrl;
}
// 2. Helper function for consistent variation number handling
function getVariationNumber(image, fallbackIndex) {
    if (typeof image.variation_number === 'number') return image.variation_number;
    if (typeof image.choice === 'number') return image.choice;
    return fallbackIndex || 0;
}
function checkTwentyTwentyInterference() {
    // Check if TwentyTwenty CSS is loaded
    const twentyTwentyCSS = document.querySelector('link[href*="twentytwenty.css"]');
    console.error('TwentyTwenty CSS loaded:', !!twentyTwentyCSS);

    // Temporarily disable it as a test
    if (twentyTwentyCSS) {
        console.error('Temporarily disabling TwentyTwenty CSS to test');
        twentyTwentyCSS.disabled = true;
    }
}


/**
 * Fixed Midjourney Display Function
 * Simplified version that ensures images display correctly
 */
function displayMidjourneyGroup(groupData) {
    console.error('Starting enhanced displayMidjourneyGroup...');

    // Make sure we have valid data
    if (!groupData || !Array.isArray(groupData.images) || groupData.images.length === 0) {
        console.error('Invalid or empty group data');
        return;
    }

    // Get and reset the main container
    const imageDiv = document.getElementById('generated-image');
    if (!imageDiv) {
        console.error('Cannot find generated-image container');
        alert('Error: Image container not found!');
        return;
    }

    // Force any containing elements to be visible
    let parent = imageDiv;
    for (let i = 0; i < 5; i++) { // Check up to 5 parent levels
        if (!parent) break;

        parent.style.display = 'block';
        parent.style.visibility = 'visible';
        parent.style.opacity = '1';
        parent.style.height = 'auto';
        parent.style.overflow = 'visible';

        parent = parent.parentElement;
    }

    // Reset the container with explicit styles
    imageDiv.innerHTML = '';
    imageDiv.style.display = 'block';
    imageDiv.style.visibility = 'visible';
    imageDiv.style.opacity = '1';
    imageDiv.style.width = '100%';
    imageDiv.style.minHeight = '400px';
    imageDiv.style.backgroundColor = '#ffffff';
    imageDiv.style.padding = '15px';
    imageDiv.style.boxSizing = 'border-box';
    imageDiv.style.border = '1px solid #e0e0e0';
    imageDiv.style.borderRadius = '8px';
    imageDiv.style.margin = '20px 0';
    imageDiv.style.boxShadow = '0 4px 6px rgba(0, 0, 0, 0.1)';

    // Create main container
    const container = document.createElement('div');
    container.style.width = '100%';
    container.style.padding = '10px';
    container.style.boxSizing = 'border-box';

    // Add prompt section
    const promptDiv = document.createElement('div');
    promptDiv.style.marginBottom = '15px';
    promptDiv.style.padding = '10px';
    promptDiv.style.backgroundColor = '#f5f5f5';
    promptDiv.style.borderRadius = '4px';

    const promptText = document.createElement('h3');
    promptText.textContent = groupData.prompt || 'No prompt available';
    promptText.style.margin = '0 0 5px 0';
    promptText.style.fontSize = '16px';
    promptText.style.fontWeight = 'bold';

    const timestampText = document.createElement('p');
    timestampText.textContent = new Date(groupData.timestamp || Date.now()).toLocaleString();
    timestampText.style.margin = '0';
    timestampText.style.fontSize = '12px';
    timestampText.style.color = '#666';

    promptDiv.appendChild(promptText);
    promptDiv.appendChild(timestampText);
    container.appendChild(promptDiv);

    // Create grid with pure inline styles
    const grid = document.createElement('div');
    grid.style.display = 'grid';
    grid.style.gridTemplateColumns = 'repeat(2, 1fr)';
    grid.style.gap = '15px';
    grid.style.padding = '0';
    grid.style.width = '100%';
    grid.style.boxSizing = 'border-box';

    // Get token for URLs
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');

    console.error(`Processing ${groupData.images.length} images`);

    // Create image elements with maximum visibility
    groupData.images.forEach((imageData, index) => {
        let image = imageData;

        // Parse image if it's a string
        if (typeof imageData === 'string') {
            try {
                image = JSON.parse(imageData);
            } catch (e) {
                console.error(`Failed to parse image ${index}:`, e);
                return;
            }
        }

        // Skip invalid images
        if (!image || !image.url) {
            console.error('Missing URL for image:', image);
            return;
        }

        // Get variation number
        const variationNum =
            typeof image.variation_number === 'number' ? image.variation_number :
            typeof image.choice === 'number' ? image.choice :
            index;

        // Ensure URL has token
        const imageUrl = image.url.includes('token=') ? image.url :
            `${image.url}${image.url.includes('?') ? '&' : '?'}token=${encodeURIComponent(token)}`;

        console.error(`Creating image ${index} with URL:`, imageUrl);

        // Create container with explicit styles for maximum visibility
        const imageContainer = document.createElement('div');
        imageContainer.style.position = 'relative';
        imageContainer.style.backgroundColor = '#f0f0f0';
        imageContainer.style.border = '1px solid #ddd';
        imageContainer.style.borderRadius = '8px';
        imageContainer.style.overflow = 'hidden';
        imageContainer.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
        imageContainer.style.transition = 'transform 0.2s';
        imageContainer.style.cursor = 'pointer';

        // Create image element with explicit styles
        const imgElement = document.createElement('img');
        imgElement.src = imageUrl;
        imgElement.alt = `Variation ${variationNum + 1}`;
        imgElement.style.width = '100%';
        imgElement.style.height = 'auto';
        imgElement.style.display = 'block';
        imgElement.style.minHeight = '150px';
        imgElement.style.backgroundColor = '#eee';

        // Add load and error handlers with visual feedback
        imgElement.onload = () => {
            console.error(`Image ${index} loaded successfully`);
            imageContainer.style.backgroundColor = '#fff';
            // Add a subtle border to show it's loaded
            imageContainer.style.border = '1px solid #ccc';
        };

        imgElement.onerror = () => {
            console.error(`Image ${index} failed to load`);
            imgElement.src = '/static/assets/img/placeholder.png';
            imageContainer.style.backgroundColor = '#ffeeee';
            imageContainer.style.border = '1px solid #ffcccc';
        };

        // Add variation number label
        const variationLabel = document.createElement('div');
        variationLabel.textContent = `V${variationNum + 1}`;
        variationLabel.style.position = 'absolute';
        variationLabel.style.bottom = '8px';
        variationLabel.style.left = '8px';
        variationLabel.style.backgroundColor = 'rgba(0,0,0,0.7)';
        variationLabel.style.color = 'white';
        variationLabel.style.padding = '4px 8px';
        variationLabel.style.borderRadius = '4px';
        variationLabel.style.fontSize = '12px';

        // Add download button (optional)
        const downloadBtn = document.createElement('button');
        downloadBtn.textContent = 'Download';
        downloadBtn.style.position = 'absolute';
        downloadBtn.style.top = '8px';
        downloadBtn.style.right = '8px';
        downloadBtn.style.backgroundColor = 'rgba(0,0,0,0.7)';
        downloadBtn.style.color = 'white';
        downloadBtn.style.border = 'none';
        downloadBtn.style.padding = '4px 8px';
        downloadBtn.style.borderRadius = '4px';
        downloadBtn.style.fontSize = '12px';
        downloadBtn.style.cursor = 'pointer';
        downloadBtn.style.opacity = '0';
        downloadBtn.style.transition = 'opacity 0.2s';

        // Show download button on hover
        imageContainer.addEventListener('mouseenter', () => {
            downloadBtn.style.opacity = '1';
        });

        imageContainer.addEventListener('mouseleave', () => {
            downloadBtn.style.opacity = '0';
        });

        // Add download functionality
        downloadBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent opening the large view
            if (typeof downloadImage === 'function') {
                downloadImage(imageUrl, 'png');
            } else {
                window.open(imageUrl, '_blank');
            }
        });

        // Add click for large image view
        imageContainer.addEventListener('click', () => {
            // Create a modal for viewing the full image
            const modal = document.createElement('div');
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0,0,0,0.9)';
            modal.style.display = 'flex';
            modal.style.alignItems = 'center';
            modal.style.justifyContent = 'center';
            modal.style.zIndex = '9999';

            const modalImg = document.createElement('img');
            modalImg.src = imageUrl;
            modalImg.style.maxWidth = '90%';
            modalImg.style.maxHeight = '90%';
            modalImg.style.objectFit = 'contain';
            modalImg.style.border = '2px solid white';

            const closeBtn = document.createElement('button');
            closeBtn.textContent = '×';
            closeBtn.style.position = 'absolute';
            closeBtn.style.top = '20px';
            closeBtn.style.right = '20px';
            closeBtn.style.backgroundColor = 'transparent';
            closeBtn.style.color = 'white';
            closeBtn.style.border = 'none';
            closeBtn.style.fontSize = '30px';
            closeBtn.style.cursor = 'pointer';

            closeBtn.addEventListener('click', () => {
                document.body.removeChild(modal);
            });

            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });

            modal.appendChild(modalImg);
            modal.appendChild(closeBtn);
            document.body.appendChild(modal);
        });

        // Assemble components
        imageContainer.appendChild(imgElement);
        imageContainer.appendChild(variationLabel);
        imageContainer.appendChild(downloadBtn);
        grid.appendChild(imageContainer);
    });

    // Add grid to container
    container.appendChild(grid);

    // Add container to page
    imageDiv.appendChild(container);

    // Show download section if it exists
    const downloadSection = document.getElementById('download-section');
    if (downloadSection) {
        downloadSection.style.display = 'block';
    }

    // Update text
    const generateText = document.getElementById('generate-text');
    if (generateText) {
        generateText.textContent = 'Générer une nouvelle image';
    }

    // Add status message at the bottom
    const statusDiv = document.createElement('div');
    statusDiv.style.marginTop = '15px';
    statusDiv.style.padding = '10px';
    statusDiv.style.backgroundColor = '#e6f7e6';
    statusDiv.style.borderRadius = '4px';
    statusDiv.style.textAlign = 'center';
    statusDiv.textContent = 'Images générées avec succès!';
    container.appendChild(statusDiv);

    console.error('Display complete, checking final state...');

    // Final visibility check
    setTimeout(() => {
        const allImgs = imageDiv.querySelectorAll('img');
        console.error(`Final check: Found ${allImgs.length} images in DOM`);

        // Force main containers to be visible again (in case something changed)
        imageDiv.style.display = 'block';
        imageDiv.style.visibility = 'visible';

        if (allImgs.length > 0) {
            const firstImg = allImgs[0];
            const rect = firstImg.getBoundingClientRect();
            console.error('First image rect:', {
                width: rect.width,
                height: rect.height,
                top: rect.top,
                left: rect.left,
                visible: rect.width > 0 && rect.height > 0
            });

            // If image has no size, try to force it
            if (rect.width === 0 || rect.height === 0) {
                console.error('Attempting to force image visibility...');
                firstImg.style.minWidth = '200px';
                firstImg.style.minHeight = '200px';
                firstImg.style.border = '2px solid red';
            }
        }

        // Try to ensure any parent container is visible
        let currentElement = imageDiv;
        while (currentElement && currentElement !== document.body) {
            if (currentElement.style) {
                currentElement.style.display = currentElement.style.display === 'none' ? 'block' : currentElement.style.display;
                currentElement.style.visibility = 'visible';
                currentElement.style.opacity = '1';
            }
            currentElement = currentElement.parentElement;
        }

        // Update history if that function exists
        if (typeof loadHistory === 'function') {
            loadHistory(1, false);
        }
    }, 500);
}
// Helper function for image downloads if not already defined
if (typeof downloadImage !== 'function') {
    window.downloadImage = function(url, format) {
        const link = document.createElement('a');
        link.href = url;
        link.download = `image.${format}`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    };
}
// Create lightbox for fullscreen image viewing
function createLightbox(imageUrl, variationNumber, prompt) {
    // Create and style lightbox container
    const lightbox = document.createElement('div');
    lightbox.className = 'midjourney-lightbox';
    lightbox.style.position = 'fixed';
    lightbox.style.top = '0';
    lightbox.style.left = '0';
    lightbox.style.width = '100%';
    lightbox.style.height = '100%';
    lightbox.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
    lightbox.style.display = 'flex';
    lightbox.style.flexDirection = 'column';
    lightbox.style.alignItems = 'center';
    lightbox.style.justifyContent = 'center';
    lightbox.style.zIndex = '9999';
    lightbox.style.opacity = '0';
    lightbox.style.transition = 'opacity 0.3s ease';

    // Lightbox header
    const lightboxHeader = document.createElement('div');
    lightboxHeader.style.position = 'absolute';
    lightboxHeader.style.top = '0';
    lightboxHeader.style.left = '0';
    lightboxHeader.style.width = '100%';
    lightboxHeader.style.padding = '16px';
    lightboxHeader.style.display = 'flex';
    lightboxHeader.style.justifyContent = 'space-between';
    lightboxHeader.style.alignItems = 'center';
    lightboxHeader.style.boxSizing = 'border-box';
    lightboxHeader.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';

    // Prompt and variation info
    const lightboxInfo = document.createElement('div');
    lightboxInfo.style.color = '#fff';

    const lightboxPrompt = document.createElement('div');
    lightboxPrompt.textContent = prompt || 'Generated Image';
    lightboxPrompt.style.fontSize = '14px';
    lightboxPrompt.style.fontWeight = '500';
    lightboxPrompt.style.marginBottom = '4px';

    const lightboxVariation = document.createElement('div');
    lightboxVariation.textContent = `Variation ${variationNumber}`;
    lightboxVariation.style.fontSize = '12px';
    lightboxVariation.style.color = 'rgba(255, 255, 255, 0.7)';

    lightboxInfo.appendChild(lightboxPrompt);
    lightboxInfo.appendChild(lightboxVariation);

    // Close button
    const lightboxClose = document.createElement('button');
    lightboxClose.innerHTML = '×';
    lightboxClose.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
    lightboxClose.style.color = '#fff';
    lightboxClose.style.border = 'none';
    lightboxClose.style.borderRadius = '50%';
    lightboxClose.style.width = '36px';
    lightboxClose.style.height = '36px';
    lightboxClose.style.fontSize = '24px';
    lightboxClose.style.display = 'flex';
    lightboxClose.style.alignItems = 'center';
    lightboxClose.style.justifyContent = 'center';
    lightboxClose.style.cursor = 'pointer';
    lightboxClose.style.transition = 'background-color 0.2s ease';

    lightboxClose.addEventListener('mouseenter', () => {
        lightboxClose.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
    });

    lightboxClose.addEventListener('mouseleave', () => {
        lightboxClose.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
    });

    lightboxClose.addEventListener('click', () => {
        lightbox.style.opacity = '0';
        setTimeout(() => {
            document.body.removeChild(lightbox);
        }, 300);
    });

    // Image container
    const lightboxImageContainer = document.createElement('div');
    lightboxImageContainer.style.maxWidth = '90%';
    lightboxImageContainer.style.maxHeight = '80%';
    lightboxImageContainer.style.display = 'flex';
    lightboxImageContainer.style.alignItems = 'center';
    lightboxImageContainer.style.justifyContent = 'center';

    // Image element
    const lightboxImage = document.createElement('img');
    lightboxImage.src = imageUrl;
    lightboxImage.alt = `Variation ${variationNumber}`;
    lightboxImage.style.maxWidth = '100%';
    lightboxImage.style.maxHeight = '100%';
    lightboxImage.style.objectFit = 'contain';
    lightboxImage.style.borderRadius = '4px';
    lightboxImage.style.boxShadow = '0 5px 25px rgba(0, 0, 0, 0.5)';

    // Download button
    const lightboxDownload = document.createElement('div');
    lightboxDownload.style.position = 'absolute';
    lightboxDownload.style.bottom = '20px';
    lightboxDownload.style.right = '20px';

    const downloadBtn = document.createElement('button');
    downloadBtn.innerHTML = `
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" style="margin-right: 8px;">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
        Télécharger
    `;
    downloadBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
    downloadBtn.style.color = '#fff';
    downloadBtn.style.border = 'none';
    downloadBtn.style.borderRadius = '4px';
    downloadBtn.style.padding = '8px 16px';
    downloadBtn.style.fontSize = '14px';
    downloadBtn.style.display = 'flex';
    downloadBtn.style.alignItems = 'center';
    downloadBtn.style.cursor = 'pointer';
    downloadBtn.style.transition = 'background-color 0.2s ease';

    downloadBtn.addEventListener('mouseenter', () => {
        downloadBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
    });

    downloadBtn.addEventListener('mouseleave', () => {
        downloadBtn.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
    });

    downloadBtn.addEventListener('click', () => {
        if (typeof downloadImage === 'function') {
            downloadImage(imageUrl, 'png');
        } else {
            window.open(imageUrl, '_blank');
        }
    });

    // Close lightbox when clicking the background
    lightbox.addEventListener('click', (e) => {
        if (e.target === lightbox) {
            lightbox.style.opacity = '0';
            setTimeout(() => {
                document.body.removeChild(lightbox);
            }, 300);
        }
    });

    // Assemble elements
    lightboxHeader.appendChild(lightboxInfo);
    lightboxHeader.appendChild(lightboxClose);

    lightboxImageContainer.appendChild(lightboxImage);

    lightboxDownload.appendChild(downloadBtn);

    lightbox.appendChild(lightboxHeader);
    lightbox.appendChild(lightboxImageContainer);
    lightbox.appendChild(lightboxDownload);

    // Add to body and show
    document.body.appendChild(lightbox);

    // Force layout calculation before adding opacity transition
    void lightbox.offsetWidth;

    // Show lightbox with transition
    lightbox.style.opacity = '1';
}


// Helper function to test the display with mock data
function testMidjourneyDisplay() {
    console.error('DEBUG: Testing display with mock data');

    // Create mock data similar to your real data
    const mockData = {
        prompt: "Test prompt for debugging",
        timestamp: new Date().toISOString(),
        images: [
            {
                choice: 1,
                url: "/static/assets/img/placeholder.png", // Use a known good image
                variation_number: 1,
                width: 1024,
                height: 1024
            },
            {
                choice: 2,
                url: "/static/assets/img/placeholder.png",
                variation_number: 2,
                width: 1024,
                height: 1024
            },
            {
                choice: 3,
                url: "/static/assets/img/placeholder.png",
                variation_number: 3,
                width: 1024,
                height: 1024
            },
            {
                choice: 4,
                url: "/static/assets/img/placeholder.png",
                variation_number: 4,
                width: 1024,
                height: 1024
            }
        ]
    };

    // Call the debug display function
    displayMidjourneyGroup(mockData);
}

// To use this debug version, add this line to your JavaScript:
// Replace your call to displayMidjourneyGroup with displayMidjourneyGroupDebug
// Or run testMidjourneyDisplay() from the console to test with mock data

function updateProgressIndicator(percentage) {
    const progressBar = document.querySelector('.progress-bar');
    if (!progressBar) {
        const progressContainer = document.createElement('div');
        progressContainer.className = 'progress-container mt-4';
        progressContainer.innerHTML = `
            <div class="w-full bg-gray-200 rounded-full h-2.5">
                <div class="progress-bar bg-blue-600 h-2.5 rounded-full transition-all duration-500"
                     style="width: ${percentage}%"></div>
            </div>
            <div class="text-sm text-gray-600 mt-2">
                Génération en cours : ${Math.round(percentage)}%
            </div>
        `;
        document.getElementById('generated-image').appendChild(progressContainer);
    } else {
        progressBar.style.width = `${percentage}%`;
        progressBar.parentElement.nextElementSibling.textContent =
            `Génération en cours : ${Math.round(percentage)}%`;
    }
}
function showImageDetail(image, prompt) {
    // Get token for URLs
    const urlParams = new URLSearchParams(window.location.search);
    const token = urlParams.get('token');

    // Ensure we have a valid URL and choice number
    const imageUrl = image.url || '';
    const fullImageUrl = imageUrl.includes('token=') ? imageUrl :
        `${imageUrl}${imageUrl.includes('?') ? '&' : '?'}token=${encodeURIComponent(token)}`;

    const choiceNum = typeof image.choice === 'number' ? image.choice :
                     (typeof image.variation_number === 'number' ? image.variation_number : 0);

    const modal = document.createElement('div');
    modal.className = 'fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50';
    modal.innerHTML = `
        <div class="bg-white w-full max-w-4xl rounded-lg p-4">
            <div class="flex justify-between items-center mb-4">
                <div>
                    <h3 class="text-xl font-semibold">Variation ${image.choice}</h3>
                    <p class="text-sm text-gray-600">${prompt}</p>
                </div>
                <button class="close-button text-gray-500 hover:text-gray-700">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                    </svg>
                </button>
            </div>
            <img src="${fullImageUrl}"
                 alt="Variation ${choiceNum + 1}"
                 class="w-full rounded-lg">
            <div class="mt-4 flex justify-between items-center">
                <div class="text-sm text-gray-600">
                    ${image.width || 1024}x${image.height || 1024}
                </div>
                <div class="dropdown">
                    <button class="fn__icon_button dropdown-toggle">
                        <img src="/static/assets/svg/download.svg" alt="" class="fn__svg">
                    </button>
                    <ul class="dropdown-menu dropdown-menu-dark">
                        <li class="dropdown-item" data-format="png" data-url="${fullImageUrl}">PNG</li>
                        <li class="dropdown-item" data-format="jpg" data-url="${fullImageUrl}">JPG</li>
                        <li class="dropdown-item" data-format="jpeg" data-url="${fullImageUrl}">JPEG</li>
                    </ul>
                </div>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    modal.querySelector('.close-button').addEventListener('click', () => {
        modal.remove();
    });

    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.remove();
        }
    });

    modal.addEventListener('click', (e) =>{
        if (e.target === modal) {
            modal.remove();
        }
    });
    // Set up download buttons
    modal.querySelectorAll('.dropdown-item').forEach(item => {
        item.addEventListener('click', (e) => {
            const format = e.target.getAttribute('data-format');
            const url = e.target.getAttribute('data-url');
            if (format && url) {
                downloadImage(url, format);
            }
        });
    });
}

function showErrorOverlay(title, message) {
    console.error(title, message);
    alert(`${title}: ${message}`);

    let errorOverlay = document.getElementById('error-overlay');
    if (!errorOverlay) {
        errorOverlay = document.createElement('div');
        errorOverlay.id = 'error-overlay';
        errorOverlay.style.position = 'fixed';
        errorOverlay.style.top = '20px';
        errorOverlay.style.left = '50%';
        errorOverlay.style.transform = 'translateX(-50%)';
        errorOverlay.style.backgroundColor = 'rgba(220, 53, 69, 0.9)';
        errorOverlay.style.color = 'white';
        errorOverlay.style.padding = '15px 20px';
        errorOverlay.style.borderRadius = '5px';
        errorOverlay.style.zIndex = '9999';
        errorOverlay.style.maxWidth = '80%';
        errorOverlay.style.textAlign = 'center';
        document.body.appendChild(errorOverlay);
    }

    // Déterminer le message en fonction du type d'erreur
    let errorMessage = message;

    if (message.includes("token") || message.includes("Token") || title.includes("token") || title.includes("Token")) {
        errorMessage = "Vous n'avez pas assez de tokens pour cette opération. <a href='/pricing.html' style='color:white;text-decoration:underline;'>Mettez à niveau votre abonnement</a> pour obtenir plus de tokens.";
    } else if (message.includes("403") || message.includes("Forbidden")) {
        errorMessage = "Accès refusé. Veuillez vous assurer que vous êtes correctement connecté.";
    } else if (message.includes("500") || message.includes("serveur")) {
        errorMessage = "Erreur interne du serveur. Notre équipe a été notifiée et travaille sur le problème. Veuillez réessayer plus tard.";
    }

    errorOverlay.innerHTML = `
        <div>
            <strong>${title}</strong><br>
            ${errorMessage}
        </div>
        <div style="margin-top:10px;">
            <button onclick="document.getElementById('error-overlay').style.display='none'"
                    style="background:white;color:#dc3545;border:none;padding:5px 10px;border-radius:3px;cursor:pointer;">
                Fermer
            </button>
        </div>
    `;

    // Faire disparaître le message après 5 secondes
    setTimeout(() => {
        if (errorOverlay && errorOverlay.parentNode) {
            errorOverlay.style.opacity = '0';
            errorOverlay.style.transition = 'opacity 0.5s ease';
            setTimeout(() => {
                if (errorOverlay && errorOverlay.parentNode) {
                    errorOverlay.parentNode.removeChild(errorOverlay);
                }
            }, 500);
        }
    }, 5000);
}

    function saveInstance(prompt, imageUrl) {
        instances.push({ prompt, imageUrl });
    }

    // function addImageToSidebar(url, index) {
    //     const sidebar = document.getElementById('sidebar');
    //     const thumbnail = document.createElement('img');
    //     thumbnail.src = url;
    //     thumbnail.onclick = () => displayInstance(index);
    //     sidebar.insertBefore(thumbnail, sidebar.querySelector('.new-image').nextSibling);
    // }

    function addImageToSidebar(url, index) {
        const sidebar = document.getElementById('sidebar');

        const listItem = `
            <li class="fn__gl_item">
                <div class="fn__gl__item">
                    <div class="abs_item">
                        <img src="${url}" alt="Image ${index}" onclick="displayInstance(${index})">
                    </div>
                </div>
            </li>
        `;

        sidebar.innerHTML += listItem;
    }

    function displayInstance(index) {
        const { prompt, imageUrl } = instances[index];
        const promptInput = document.getElementById('prompt');
        const imageDiv = document.getElementById('generated-image');
        const downloadSection = document.querySelector('.fn__generation_item .item_list .fn__generation_list');

        promptInput.value = prompt;
        promptInput.disabled = true;
        imageDiv.innerHTML = `<img src="${imageUrl}" class="img-fluid mt-3" alt="Generated Image">`;
        downloadSection.style.display = 'block';
        generatedImageUrl = imageUrl;

        document.getElementById('generate-text').textContent = 'Générer une nouvelle image';

    }
    function createNewInstance() {
        document.getElementById('prompt').value = '';
        document.getElementById('prompt').disabled = false;
        document.getElementById('generated-image').innerHTML = '';
        document.getElementById('download-section').style.display = 'none';
        document.getElementById('generate-text').textContent = 'Générer l\'image';
    }

    function handleGroupClick(taskId) {
        console.error(`Handling click on group ${taskId}`);
        if (!taskId) {
            console.error("No taks ID porvided");
            return;
        }

        const mainContainer = document.getElementById('generated-image');
        if (mainContainer) {
            mainContainer.innerHTML = `
                <div style="display: flex; justify-content: center; align-items: center; min-height: 200px;">
                    <div style="text-align: center;">
                        <div style="border: 3px solid #555; border-top: 3px solid #fff; border-radius: 50%;
                                    width: 30px; height: 30px; margin: 0 auto; animation: spin 1s linear infinite;"></div>
                        <p style="margin-top: 15px; color: #ccc;">Chargement des images...</p>
                    </div>
                </div>
                <style>
                    @keyframes spin {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(360deg); }
                    }
                </style>
            `;
        }
        // Get token for authentication
        const urlParams = new URLSearchParams(window.location.search);
        const token = urlParams.get('token');

        // Fetch the task status
        fetch(`/check_midjourney_status/${taskId}?token=${encodeURIComponent(token)}`, {
            headers: {
                'X-Requested-With': 'XMLHttpRequest'
            }
        })
        .then(response => response.json())
        .then(data => {
            console.error("Got midjourney status data:", data);
            if (data.success && data.data) {
                // Call the display function with the group data
                displayMidjourneyGroup(data.data);

                // Update other UI elements
                if (document.getElementById('prompt')) {
                    document.getElementById('prompt').value = data.data.prompt || '';
                }

                // Show the download section
                const downloadSection = document.getElementById('download-section');
                if (downloadSection) {
                    downloadSection.style.display = 'block';
                }
            } else {
                console.error("Failed to load midjourney group data");
                if (mainContainer) {
                    mainContainer.innerHTML = `<p style="color: #ff6b6b; text-align: center; padding: 20px;">
                        Impossible de charger les images. Veuillez réessayer.</p>`;
                }
            }
        })
        .catch(error => {
            console.error("Error fetching group data:", error);
            if (mainContainer) {
                mainContainer.innerHTML = `<p style="color: #ff6b6b; text-align: center; padding: 20px;">
                    Erreur lors du chargement des images.</p>`;
            }
        });

    }
    function downloadImage(url, format) {
        console.error('Starting download:', {url, format});
        if (!url) {
            console.error('No URL provided for download');
            alert('URL de téléchargement manquante');
            return;
        }

        const img = new Image();
        img.crossOrigin = 'anonymous';

        // Add loading indicator
        const loadingIndicator = document.createElement('div');
        loadingIndicator.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
        loadingIndicator.innerHTML = `
            <div class="bg-white p-4 rounded">
                <div class="spinner-border" role="status"></div>
                <p class="mt-2">Téléchargement en cours...</p>
            </div>
        `;
        document.body.appendChild(loadingIndicator);

        img.onload = function () {
            console.error('Image loaded successfully');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);
            canvas.toBlob(function (blob) {
                loadingIndicator.remove();
                if (!blob) {
                    console.error('Failed to create blob');
                    alert('Échec de la création du fichier image');
                    return;
                }
                console.error('Blob created successfully');
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `image.${format.toLowerCase()}`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            }, `image/${format.toLowerCase()}`, 1.0);
        };
        // Gestion des erreurs
        img.onerror = function () {
            console.error('Erreur lors du chargement de l\'image');
            alert('Impossible de télécharger l\'image. Veuillez réessayer.');
        };

        // Set timeout to handle hanging requests
        setTimeout(() => {
            if (!img.complete) {
                loadingIndicator.remove();
                console.error('Image download timed out');
                alert('Le téléchargement a expiré. Veuillez réessayer.');
            }
        }, 20000);

        img.src = url;
    }

    function createHistoryItem(item, delay=0) {
            console.error("creating history with item:", item)
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');
            const fullImageUrl = `${item.url}?token=${encodeURIComponent(token)}`;
            const listItem = document.createElement('li');
            listItem.className = 'fn__gl_item';

            if (item.model === 'midjourney' && item.images && item.images.length > 0) {
                // Créer un aperçu du groupe Midjourney

                listItem.dataset.taskId = item.task_id || '';

                let thumbnailsHtml = '';

                const imagesToShow = item.images.slice(0, 4);
                imagesToShow.forEach((img, index) => {
                   // Ensure image URL is properly formatted
                    let imageUrl = img.url;
                    if (!imageUrl.startsWith('http') && !imageUrl.startsWith('/')) {
                        imageUrl = `/image/${img.key}`;
                    }
                    if (!imageUrl.includes('token=') && token) {
                        imageUrl += (imageUrl.includes('?') ? '&' : '?') + `token=${encodeURIComponent(token)}`;
                    }

                    thumbnailsHtml += `
                        <div style="width: 50%; height: 50%; padding: 1px; box-sizing: border-box;">
                            <img src="${imageUrl}"
                                 alt="V${index + 1}"
                                 style="width: 100%; height: 100%; object-fit: cover; display: block;">
                        </div>
                    `;
                });

                listItem.innerHTML = `
                    <div class="fn__gl__item">
                        <div class="abs_item">
                            <div style="position: relative; width: 100%; height: 100%; border-radius: 8px; overflow: hidden;">
                                <div style="display: flex; flex-wrap: wrap; width: 100%; height: 100%;">
                                    ${thumbnailsHtml}
                                </div>
                                <div style="position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7);
                                            color: white; padding: 4px; font-size: 10px; text-overflow: ellipsis;
                                            overflow: hidden; white-space: nowrap;">
                                    ${item.prompt || ''}
                                </div>
                            </div>
                        </div>
                    </div>
                `;


                // Gestionnaire d'événements pour l'ouverture du groupe
                listItem.addEventListener('click', () => {
                    handleGroupClick(item.taskId);
                });

            } else {
                listItem.innerHTML = `
                <div class="fn__gl__item">
                    <div class="abs_item">
                        <img src="${fullImageUrl}" alt="Generated image" loading="lazy">
                        <div class="prompt">${item.prompt}</div>
                        <div class="timestamp">${new Date(item.timestamp).toLocaleString()}</div>
                        <!-- Ajout du bouton de téléchargement similaire à celui des nouvelles images -->
                        <div class="all_options">
                            <div class="fn__icon_options medium_size">
                                <div class="dropdown">
                                    <button class="fn__icon_button dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false">
                                        <img src="/static/assets/svg/download.svg" alt="" class="fn__svg">
                                    </button>
                                    <ul class="dropdown-menu dropdown-menu-dark">
                                        <li class="dropdown-item" data-format="png" data-url="${fullImageUrl}">PNG</li>
                                        <li class="dropdown-item" data-format="jpg" data-url="${fullImageUrl}">JPG</li>
                                        <li class="dropdown-item" data-format="jpeg" data-url="${fullImageUrl}">JPEG</li>
                                        <li class="dropdown-item" data-format="gif" data-url="${fullImageUrl}">GIF</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;


            // Empêcher la propagation du clic pour les boutons de téléchargement
            const downloadButtons = listItem.querySelectorAll('.dropdown-item, .dropdown-toggle');
            downloadButtons.forEach(button => {
                button.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const format = button.getAttribute('data-format');
                    const imageUrl = button.getAttribute('data-url');
                    if (format && imageUrl) {
                        downloadImage(imageUrl, format);
                    }
                });
            });

            const img = listItem.querySelector('img');
            img.addEventListener('click', () => {
                const mainImageContainer = document.getElementById('generated-image');
                const downloadSection = document.getElementById('download-section');
                mainImageContainer.innerHTML = `<img src="${fullImageUrl}" class="img-fluid mt-3" alt="Generated Image">`;
                document.getElementById('prompt').value = item.prompt;
                downloadSection.style.display = 'block';
                generatedImageUrl = fullImageUrl;
            });

             // Ajouter le délai d'animation
            listItem.style.animationDelay = `${delay}ms`;

            }

            return listItem;

        }

        // Chargement automatique au scroll
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && hasMore && !isLoading) {
                    loadHistory(currentPage + 1, true);
                }
            });
        }, {
            rootMargin: '100px'
        });
        // Observer le loader
        observer.observe(document.getElementById('historyLoader'));

        // Chargement initial de l'historique
        //document.addEventListener('DOMContentLoaded', () => {
            //loadHistory(1, false);
        //});
    function showMidjourneyDetail(groupData) {
    const detailView = document.createElement('div');
    detailView.className = 'midjourney-detail-view';

    detailView.innerHTML = `
        <div class="midjourney-detail-content">
            <div class="detail-header">
                <h3>${groupData.prompt}</h3>
                <button class="close-button">×</button>
            </div>
            <div class="midjourney-variations-grid">
                ${groupData.images.map((img, index) => `
                    <div class="variation-item">
                        <img src="${img.url}?token=${encodeURIComponent(token)}"
                             alt="Variation ${index + 1}"
                             class="variation-image">
                        <div class="variation-number">V${index + 1}</div>
                        <div class="all_options">
                            <div class="fn__icon_options medium_size">
                                <div class="dropdown">
                                    <button class="fn__icon_button dropdown-toggle" type="button" data-bs-toggle="dropdown">
                                        <img src="/static/assets/svg/download.svg" alt="" class="fn__svg">
                                    </button>
                                    <ul class="dropdown-menu dropdown-menu-dark">
                                        <li class="dropdown-item" data-format="png" data-url="${img.url}">PNG</li>
                                        <li class="dropdown-item" data-format="jpg" data-url="${img.url}">JPG</li>
                                        <li class="dropdown-item" data-format="jpeg" data-url="${img.url}">JPEG</li>
                                        <li class="dropdown-item" data-format="gif" data-url="${img.url}">GIF</li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;

    // Fermeture de la vue détaillée
    detailView.querySelector('.close-button').addEventListener('click', () => {
        detailView.remove();
    });

    // Clic sur l'arrière-plan pour fermer
    detailView.addEventListener('click', (e) => {
        if (e.target === detailView) {
            detailView.remove();
        }
    });

    document.body.appendChild(detailView);
}

    // Fonction pour charger l'historique
        async function loadHistory(page = 1, append = false) {
            console.error(`Fetching history for page ${page}...`);
            if (isLoading || (!append && !hasMore)) return;

            const historyLoader = document.getElementById('historyLoader');
            const historyContent = document.querySelector('.generation_history .fn__generation_list.sidebar');

            isLoading = true;
            historyLoader.classList.remove('d-none');

            try {
                const urlParams = new URLSearchParams(window.location.search);
                const token = urlParams.get('token');

                // Utiliser l'endpoint approprié pour votre historique
                const endpoint = '/api/chat/history/generated';
                const url = `${endpoint}?page=${page}&token=${encodeURIComponent(token)}`;

                const response = await fetch(url, {
                    headers: {
                        'X-Requested-With': 'XMLHttpRequest'
                    }
                });

                if (!response.ok) {
                    if (response.status === 401 || response.status === 403) {
                        window.location.href = LOGIN_URL;
                        return;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                console.error('Fetched data:', data);

                if (!append) {
                    historyContent.innerHTML = '';
                }

                const items = data.data?.items || [];

                if (items.length > 0) {
                    items.forEach((item, index) => {
                        console.error('Processing item:', {
                            index,
                            rawItem: item,
                            modelFromParams: item.parameters?.model,
                            url: item.url,
                            imageUrl: item.image_url, // Au cas où l'URL serait sous un nom différent
                            prompt: item.prompt,
                            timestamp: item.timestamp
                        });
                       // Normaliser les données selon le modèle
                        const normalizedItem = {
                            url: item.url || item.image_url,
                            prompt: item.prompt,
                            timestamp: item.timestamp,
                            model: item.model || currentModel // Utiliser le modèle courant si non spécifié
                        };

                        // Vérifier que nous avons une URL valide
                        if (!normalizedItem.url) {
                            console.error('Missing URL for item:', normalizedItem);
                            return; // Skip this item
                        }

                        const delay = index * 100;
                        const historyItem = createHistoryItem(normalizedItem, delay);
                        historyContent.appendChild(historyItem);
                    });

                    hasMore = data.data?.pagination?.has_more || false;
                    currentPage = page;

                    // Gestion du bouton "Charger plus"
                    if (hasMore) {
                        if (!document.getElementById('loadMoreBtn')) {
                            const loadMoreBtn = document.createElement('button');
                            loadMoreBtn.id = 'loadMoreBtn';
                            loadMoreBtn.className = 'load-more';
                            loadMoreBtn.textContent = 'Charger plus';
                            loadMoreBtn.onclick = () => loadHistory(currentPage + 1, true);
                            historyContent.after(loadMoreBtn);
                        }
                    } else {
                        const loadMoreBtn = document.getElementById('loadMoreBtn');
                        if (loadMoreBtn) loadMoreBtn.remove();
                    }
                } else {
                    if (!append) {
                        historyContent.innerHTML = '<p class="text-center">Aucun historique disponible</p>';
                    }
                    hasMore = false;
                }

            } catch (error) {
                console.error('Error loading history:', error);
                if (!append) {
                    historyContent.innerHTML = '<p class="text-center text-danger">Erreur lors du chargement de l\'historique</p>';
                }
            } finally {
                isLoading = false;
                historyLoader.classList.add('d-none');
            }
        }
        async function validateImageUrl(imageUrl, token) {
            try {
                const fullUrl = `${imageUrl}?token=${encodeURIComponent(token)}`;
                const response = await fetch(fullUrl, { method: 'HEAD' });

                if (!response.ok) {
                    console.error('Debug - Image validation failed:', response.status);
                    return false;
                }

                const contentType = response.headers.get('content-type');
                return contentType && contentType.startsWith('image/');
            } catch (error) {
                console.error('Debug - Image validation error:', error);
                return false;
            }
        }


        document.addEventListener('DOMContentLoaded', function() {
            // Récupérer le token de l'URL actuelle
            const urlParams = new URLSearchParams(window.location.search);
            const token = urlParams.get('token');

            updateTokenCost();

            if (token) {
                // Modifier tous les liens de navigation pour inclure le token
                document.querySelectorAll('.neltar_fn_wrapper a').forEach(link => {
                    // Vérifier si c'est un lien interne
                    if (link.href.startsWith(window.location.origin)) {
                        const url = new URL(link.href);
                        url.searchParams.set('token', token);
                        link.href = url.toString();
                    }
                });
                // Modifier tous les formulaires pour inclure le token
                document.querySelectorAll('form').forEach(form => {
                    const input = document.createElement('input');
                    input.type = 'hidden';
                    input.name = 'token';
                    input.value = token;
                    form.appendChild(input);
                });
            }

            document.addEventListener('click', function(event) {
                const dropdownItem = event.target.closest('.dropdown-item');
                if (dropdownItem) {
                    const format = dropdownItem.getAttribute('data-format');
                    const imageUrl = dropdownItem.getAttribute('data-url') || generatedImageUrl;

                    console.log('Download clicked:', {format, imageUrl});

                    if (format && imageUrl) {
                        downloadImage(imageUrl, format);
                        // Fermer le dropdown après la sélection
                        const dropdownMenu = dropdownItem.closest('.dropdown-menu');
                        if (dropdownMenu) {
                            dropdownMenu.classList.remove('show');
                        }
                    }
                }
            });

            // Intercepter fetch pour les  erreurs d'authentification
            fetch = (originalFetch => {
                return async (...arguments) => {
                    try {
                        const response = await originalFetch(...arguments);
                        if (response.status === 401 || response.status === 403) {
                            const data = await response.json();
                            if (data.redirect_url) {
                                window.location.href = data.redirect_url;
                                return;
                            }
                        }
                        return response;
                    } catch (error) {
                        throw error;
                    }
                };
            })(fetch);

            loadHistory(1, false);
        });
</script>




{% endblock %}

